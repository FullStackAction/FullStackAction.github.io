(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{442:function(t,a,e){"use strict";e.r(a);var n=e(15),o=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("blockquote",[a("p",[t._v("OC无法做到面向协议开发，而Swift可以，因为Swift可以做到协议方法的具体实现，而OC不行")])]),t._v(" "),a("h2",{attrs:{id:"面向对象开发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象开发"}},[t._v("#")]),t._v(" 面向对象开发")]),t._v(" "),a("p",[t._v("传统的面向对象开发思维方式是将类中实现的相似方法抽取出来，接着放入一个Base类，然后继承于Base类后各个类即可找拥有相同的方法，不用再一个个手动实现。\n比如：一个Person类，一个Dog类，它们都拥有方法eat，那么就可以新建一个Animal类，将eat方法抽取出来放入其中，然后将Person类和Dog类都继承于Animal。\n但是，如果现在又有一个Robot类，也需要拥有eat方法，而此时也将其继承于Animal的话显然是不合理的，于是我们就需要转换思维，面向协议开发~")]),t._v(" "),a("h2",{attrs:{id:"面向协议开发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向协议开发"}},[t._v("#")]),t._v(" 面向协议开发")]),t._v(" "),a("p",[t._v("面向协议开发的核心是：** 模块化（组件化） **\n我们先来回顾下协议的一般使用，新建一个Swift文件LXFProtocol.swift")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import Foundation\n\nprotocol LXFProtocol {\n    func eat()\n}\n")])])]),a("p",[t._v("我们的Person类遵守协议LXFProtocol，需要我们实现协议中的方法，如：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("class Person: NSObject, LXFProtocol {\n    func eat() {\n        //\n    }\n}\n")])])]),a("p",[t._v("那我们每个类都这样做的话跟直接复制粘贴代码并没什么不同~~\n而开头已经提到一点：")]),t._v(" "),a("blockquote",[a("p",[t._v("Swift可以做到协议方法的具体实现")])]),t._v(" "),a("p",[t._v("\b那么现在，我们新建一个Swift文件Eatable.swift，以区分LXFProtocol.swift\nEatable.swift中的代码实现如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import Foundation\n\nprotocol Eatable {\n    // 可声明变量\n}\n\nextension Eatable {\n    func eat() {\n        // 实现具体的功能\n    }\n}\n")])])]),a("p",[t._v("有2个注意点")]),t._v(" "),a("ul",[a("li",[t._v("protocol中可以声明变量，\b方便在协议方法中使用")]),t._v(" "),a("li",[t._v("协议方法的具体实现需要在extension中来实现")])]),t._v(" "),a("p",[t._v("使Dog类遵守Eatable")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("class Dog: NSObject, Eatable {\n\n}\n")])])]),a("p",[t._v("这样我们就可以在其它地方轻松调用dog的eat方法，Person类与Robot类也是如法炮制\n"),a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210110213024.png",alt:""}})]),t._v(" "),a("p",[t._v("至此，我们就可以通过面向协议的方式给类定制不同的功能，也就是模块化。可以发现Swift的面向协议编程跟c++的多继承很相似")]),t._v(" "),a("h2",{attrs:{id:"约束"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#约束"}},[t._v("#")]),t._v(" 约束")]),t._v(" "),a("p",[t._v("现在的这个Eatable协议是可以被\b任意遵守的，如果我们\b有这么个需求，我们创建的协议只是被UIViewController遵守，那我们该怎么做呢？\n【当然，Eatable协议只能被UIViewController遵守很扯淡，这里只是举例，不要太在意咯~~】")]),t._v(" "),a("blockquote",[a("p",[t._v("在 extension 后面加上约束关键字【where】，并注明该协议只能被UIViewController这个类（包括子类）所遵守，而且此时我们还可以拿到遵守该协议的控制器的view")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//import Foundation\nimport UIKit\n\nprotocol Eatable {\n    \n}\n\nextension Eatable where Self : UIViewController {\n    func eat() {\n        view.backgroundColor = UIColor.red\n    }\n}\n")])])]),a("p",[a("a",{attrs:{href:"https://github.com/LinXunFeng/LXFPOP",target:"_blank",rel:"noopener noreferrer"}},[t._v("Demo"),a("OutboundLink")],1),t._v("\n接下来以一个实际应用来巩固下吧 "),a("RouterLink",{attrs:{to:"/2017/09/12/iOS-Swift-面向协议编程（二）/"}},[t._v("iOS - Swift 面向协议编程（二）")])],1)])}),[],!1,null,null,null);a.default=o.exports}}]);
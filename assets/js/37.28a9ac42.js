(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{446:function(e,t,n){"use strict";n.r(t);var a=n(21),s=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"一、简述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、简述"}},[e._v("#")]),e._v(" 一、简述")]),e._v(" "),t("p",[e._v("众所周知，移动端（不管是Android还是iOS）使用的数据库是Sqlite，这种小型的数据库很适合移动端存储大量的数据，使用上也跟mysql基本无差，但官方提供的API在操作性方面真不咋的，你必须掌握一定程度的sql语句，否则将很难驾驭。所以，有很多第三方的数据库框架就开始流行，如：GreenDao、Litepal等。这些ORM数据库框架，可以帮助开发者节省大量编写数据库操作代码的时间，只需对对象进行赋值操作，便能作用到数据库上，方便我们开发更加复杂的业务逻辑。本篇的主题就是做一个简易的数据库框架，使用设计模式、泛型、注解、反射这些高级技巧来实现。")]),e._v(" "),t("h2",{attrs:{id:"二、数据库常用操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、数据库常用操作"}},[e._v("#")]),e._v(" 二、数据库常用操作")]),e._v(" "),t("p",[e._v("数据库操作无非就是增删改查（CRUD），而且一般操作数据库表的类称为Dao类，所以可以为这些Dao类抽取一个共同的接口：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public interface IBaseDao<M> {\n\n    Long insert(M entity);\n\n    Integer delete(M where);\n\n    Integer update(M entitiy, M where);\n\n    List<M> query(M where);\n\n    List<M> query(M where, String orderBy);\n\n    List<M> query(M where, String orderBy, Integer page, Integer pageCount);\n\n}\n")])])]),t("p",[e._v("我们要做的数据库框架也是一个ORM框架，表现层不涉及任何sql语句，直接操作的是数据对象，但具体的数据类型在这个接口中并不清楚，所以使用泛型来表示。")]),e._v(" "),t("h2",{attrs:{id:"三、dao类工厂"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、dao类工厂"}},[e._v("#")]),e._v(" 三、Dao类工厂")]),e._v(" "),t("p",[e._v("一个程序，一般只有一个数据库，一个数据库中会包含多张表，例如用户表，权限表等，这就意味着，项目中，Dao类会有多个，因为数据库操作无非是CRUD，所以可以确定它们的结构相同，只是具体操作的表与字段不同（即数据类型不同），所以，使用“泛型+工厂”来生产这些Dao类最合适不过。下面先贴出Dao类工厂代码，再一一分析：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public class BaseDaoFactory {\n\n    private static String mDbPath;\n    private SQLiteDatabase mDatabase;\n\n    private static class Instance {\n        public static BaseDaoFactory INSTANCE = new BaseDaoFactory();\n    }\n\n    public static BaseDaoFactory getInstance() {\n        return Instance.INSTANCE;\n    }\n\n    // 初始化数据库位置\n    public static void init(String dbPath) {\n        mDbPath = dbPath;\n    }\n\n    public BaseDaoFactory() {\n        if (TextUtils.isEmpty(mDbPath)) {\n            throw new RuntimeException("在使用BaseDaoFactory之前，请调用BaseDaoFactory.init()初始化好数据库路径。");\n        }\n        // 打开数据库，得到数据库对象\n        mDatabase = SQLiteDatabase.openOrCreateDatabase(mDbPath, null);\n    }\n\n    public <T extends BaseDao<M>, M> T getDataHelper(Class<T> clazz, Class<M> entity) {\n        T baseDao = null;\n        try {\n            baseDao = clazz.newInstance();\n            baseDao.init(mDatabase, entity);\n        } catch (InstantiationException e) {\n            e.printStackTrace();\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n        return baseDao;\n    }\n}\n')])])]),t("h3",{attrs:{id:"_1、数据库位置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、数据库位置"}},[e._v("#")]),e._v(" 1、数据库位置")]),e._v(" "),t("p",[e._v("使用SQLiteDatabase，可以在任意位置创建或打开一个数据库，这样的好处是：如果，用SQLiteOpenHelper来创建数据库，默认会将数据库文件创建到/data/data/包名/databases目录下，当应用被删除时，数据库也将同应用一起被删除，有时我们会有这样的需求，在用户重装安装App时，可以使用之前的数据库信息，例如：UC浏览器的书签本地恢复功能。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('// 初始化数据库位置\npublic static void init(String dbPath) {\n    mDbPath = dbPath;\n}\n\npublic BaseDaoFactory() {\n    if (TextUtils.isEmpty(mDbPath)) {\n        throw new RuntimeException("在使用BaseDaoFactory之前，请调用BaseDaoFactory.init()初始化好数据库路径。");\n    }\n    // 打开数据库，得到数据库对象\n    mDatabase = SQLiteDatabase.openOrCreateDatabase(mDbPath, null);\n}\n')])])]),t("p",[e._v("本框架可以让开发者自定义数据库的存放位置，因为在构造函数中会使用到该路径对数据库进行创建，所以这里使用静态方法的方式，在Dao工厂实例化之前先对其（mDbPath）进行赋值。这种方式在很多第三方框架的源码中很是常见，一般在自定义的Application中对通过调用框架的init()方法对框架中必需的变量进行赋值。")]),e._v(" "),t("h3",{attrs:{id:"_2、工厂单例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、工厂单例"}},[e._v("#")]),e._v(" 2、工厂单例")]),e._v(" "),t("p",[e._v("该框架中的Dao类工厂只要一个就够了，所以需要用到单例模式，常见的单例模式有饿汉式和懒汉式，这里选用静态内部类单例模式，原因是什么呢？")]),e._v(" "),t("h4",{attrs:{id:"_1-饿汉式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-饿汉式"}},[e._v("#")]),e._v(" 1）饿汉式")]),e._v(" "),t("p",[e._v("饿汉式在类加载时就已经初始化好了，不管项目中是否使用，都会占用内存，虽然效率高，但开发中一般不用。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public class BaseDaoFactory {\n\tprivate static BaseDaoFactory Instance = new BaseDaoFactory();\n    public static BaseDaoFactory getInstance() {\n        return Instance;\n    }\n}\n")])])]),t("h4",{attrs:{id:"_2-懒汉式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-懒汉式"}},[e._v("#")]),e._v(" 2）懒汉式")]),e._v(" "),t("p",[e._v("懒汉式虽然解决了饿汉式的弊端，实现调用时创建单例，但线程不安全，当然我们可以使用双重检测机制来解决，但这样也降低了效率（至少第一次初始化时需要同步，降低了效率），是开发中最常见的单例实现方式。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public class BaseDaoFactory {\n\tprivate static BaseDaoFactory mInstance;\n    public static BaseDaoFactory getInstance() {\n        if (mInstance == null) {\n            synchronized (BaseDaoFactory.class) {\n                if (mInstance == null) {\n                    mInstance = new BaseDaoFactory();\n                }\n            }\n        }\n        return mInstance;\n    }\n}\n")])])]),t("h4",{attrs:{id:"_3-静态内部类单例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-静态内部类单例"}},[e._v("#")]),e._v(" 3）静态内部类单例")]),e._v(" "),t("p",[e._v("静态内部类单例综合了前面两者的优点，即调用时创建单例，效率高且没有线程安全问题。当在调用getInstance()方法创建工厂单例时，静态内部类Instance才会被加载，同时初始化内部类属性INSTANCE，即初始化外部类BaseDaoFactory对象（Dao工厂），因为该静态内部类只会加载一次，所以该INSTANCE对象也只会被创建一次。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("private static class Instance {\n    public static BaseDaoFactory INSTANCE = new BaseDaoFactory();\n}\n\npublic static BaseDaoFactory getInstance() {\n    return Instance.INSTANCE;\n}\n\n// 单例模式，一般会将构造函数私有化，以保证不会被外界初始化。\nprivate BaseDaoFactory() {\n   ...\n}\n")])])]),t("h3",{attrs:{id:"_3、生产dao类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、生产dao类"}},[e._v("#")]),e._v(" 3、生产Dao类")]),e._v(" "),t("p",[e._v("Dao工厂会提供一个public方法来供外界获取需要的Dao类，而外界只需要传入具体Dao类和数据实体类对应的class即可。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public <T extends BaseDao<M>, M> T getDataHelper(Class<T> clazz, Class<M> entity) {\n    T baseDao = null;\n    try {\n        baseDao = clazz.newInstance();\n        baseDao.init(mDatabase, entity);\n    } catch (InstantiationException e) {\n        e.printStackTrace();\n    } catch (IllegalAccessException e) {\n        e.printStackTrace();\n    }\n    return baseDao;\n}\n")])])]),t("p",[e._v("可能这部分代码比较迷的地方就是"),t("code",[e._v("<T extends BaseDao<M>, M>")]),e._v("了（先抛开方法体中的具体实现），其实这只是方法声明泛型的方式而已。我们知道，类上声明泛型很简单，只需要在类后面加上"),t("code",[e._v("<T\\>")]),e._v("（字母随意）即可，如：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 类上泛型可以声明多个\npublic class Person<M,T> {\n    ...\n}\n")])])]),t("p",[e._v("而方法上声明泛型跟类上声明泛型有些区别——泛型声明的位置不同，方法上的泛型需要在修饰符（public等）与返回值之间声明，如：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public <T> void eat(){\n    ...\n}\n")])])]),t("p",[e._v("上面的代码不会报错，但一点意义都没有，因为泛型没被使用到，一般方法上声明的泛型可作为方法参数类型和返回值类型，如：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 同样，方法泛型也可以声明多个\npublic <T,M> T eat(T t, M m){\n    ...\n}\n")])])]),t("p",[e._v("可以这样认为，默认泛型表示的是Object（编码时），有时我们需要更加精确泛型的类型，这可以通过extends办到，如：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public <T extends Person> void doSomething(T t){\n    ...\n}\n")])])]),t("p",[e._v("这时，传入doSomething()的参数必须是Person的子类（Boy或Girl），且在编码时，可以在方法体中使用t调用Person中声明的方法，如eat()，如果不使用extends来指定泛型T的具体类型，那么在编码时，t会被认为是Object类型，也就没法调用eat()这类自定义的方法了。到这里，回头再看上面的代码，应该就不会迷了。")]),e._v(" "),t("h2",{attrs:{id:"四、数据库操作封装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、数据库操作封装"}},[e._v("#")]),e._v(" 四、数据库操作封装")]),e._v(" "),t("p",[e._v("前面一开始的时候就已经为Dao类抽取了一个共同的接口，规范了Dao类的基本操作，而且，我们不想在具体的Dao类中直接操作数据库，所以，在这两者中间必须有一层来完成数据库操作，并对各操作方法进行封装，它就是BaseDao，以下是该类中可供外界调用的方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public abstract class BaseDao<M> implements IBaseDao<M> {\n    protected boolean init(SQLiteDatabase database, Class<M> entity) {\n        ...\n    }\n    @Override\n    public Long insert(M entity) {\n        ...\n    }\n    @Override\n    public Integer delete(M where) {\n        ...\n    }\n\n    @Override\n    public Integer update(M entitiy, M where) {\n        ...\n    }\n\n    @Override\n    public List<M> query(M where) {\n        ...\n    }\n\n    @Override\n    public List<M> query(M where, String orderBy) {\n        ...\n    }\n\n    @Override\n    public List<M> query(M where, String orderBy, Integer page, Integer pageCount) {\n        ...\n    }\n}\n")])])]),t("blockquote",[t("p",[e._v("在框架设计中，要切记，不需要被外界（表现层）所知的方法或属性请尽量私有化，一来对框架安全，二来避免团队开发中不必要的冲突。因为BaseDao的init()方法只被DaoFactory调用，且两者均在同包下，故使用protected修饰。")])]),e._v(" "),t("h3",{attrs:{id:"_1、自定义注解-tbname和tbfield"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、自定义注解-tbname和tbfield"}},[e._v("#")]),e._v(" 1、自定义注解：TbName和TbField")]),e._v(" "),t("p",[e._v("在对BaseDao进行解析前，先来说说两个十分重要的注解——TbName和TbField。几乎市面上所有的ORM数据库框架，都会用到自定义注解来对一个数据实体进行描述，比如User类的类名对应表的表名，有可能是user，也有可能是t_user，那开发者就可以使用框架提供的注解（TbName）来进行自定义表名了，同理，类中的属性名对应表的字段名也是如此，不过对于表的初始化还需要知道表字段的长度，所以表字段注解（TbField）还多了一个length属性。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("/**\n * 表名注解\n */\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface TbName {\n    String value();\n}\n\n/**\n * 表字段注解\n */\n@Target(ElementType.FIELD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface TbField {\n    String value();\n    int length();\n}\n")])])]),t("blockquote",[t("p",[e._v("一方面，BaseDao对TbName和TbField的解析是处于程序运行阶段，所以这2个注解必须是运行时可见，即Retention的值必须是RetentionPolicy.RUNTIME。\n另一方面，TbName是要注解在类上的，所以其Target的值是ElementType.TYPE；而TbField则是注解在类属性上的，所以其Target的值是ElementType.FIELD。")])]),e._v(" "),t("h3",{attrs:{id:"_2、dao类初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、dao类初始化"}},[e._v("#")]),e._v(" 2、Dao类初始化")]),e._v(" "),t("p",[e._v("在Dao工厂中就已经使用了这个BaseDao的init()方法，来对Dao类进行一些通用的初始化工作，下面就来看看它都初始化了什么：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("/**\n * 初始化表操作对象，一般包括：创建表、获取表字段与类字段的映射关系\n */\nprotected boolean init(SQLiteDatabase database, Class<M> entity) {\n    mDatabase = database;\n    mEntityClass = entity;\n    \n    // 往后的操作必须是基于数据库已经打开的前提下\n    if (!database.isOpen()) {\n        return false;\n    }\n\n    // 获取表名\n    TbName tbName = entity.getAnnotation(TbName.class);\n    mTbName = tbName == null ? entity.getSimpleName() : tbName.value();\n\n    // 获取表映射字段\n    if (!genFieldMap()) {\n        return false;\n    }\n\n    // 创建数据库\n    if (!createTable(database)) {\n        return false;\n    }\n\n    return true;\n}\n")])])]),t("p",[e._v("在这个init()方法中，可以看到，注解TbName率先被该框架使用到了，当开发者有使用该注解时，表名以TbName注解中的值为表名，否则以类名作为表名。")]),e._v(" "),t("blockquote",[t("p",[e._v("注解是“静态的”，在类加载时就已经固定了，也就是说运行时无法修改其值（javassist方式除外），所以，可以利用类的class对象，通过 getAnnotation(注解.class).注解属性() 这种方法也获取注解的属性值。")])]),e._v(" "),t("h4",{attrs:{id:"_1-获取表字段与类字段的映射关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-获取表字段与类字段的映射关系"}},[e._v("#")]),e._v(" 1）获取表字段与类字段的映射关系")]),e._v(" "),t("p",[e._v("我们知道，类的属性名可能会与表的字段名不同，而BaseDao中的很多后续操作都会跟这两者打交道，所以，在BaseDao的初始化过程中将这两者的关系使用Map进行保存，方便后续的各种操作。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('private boolean genFieldMap() {\n    mFieldMap = new HashMap<>();\n    Field[] fields = mEntityClass.getFields();\n    if (fields == null || fields.length == 0) {\n        Log.e(TAG, "获取不到类中字段");\n        return false;\n    }\n    for (Field field : fields) {\n        field.setAccessible(true);\n        TbField tbField = field.getAnnotation(TbField.class);\n        mFieldMap.put(tbField == null ? field.getName() : tbField.value(), field);\n    }\n    return true;\n}    \n')])])]),t("p",[e._v("反射中的几个小知识点：")]),e._v(" "),t("ul",[t("li",[e._v("Field[] fields = mEntityClass.getFields();// 得到类中的public字段，包括父类。")]),e._v(" "),t("li",[e._v("Field[] fields = mEntityClass.getDeclaredFields();// 得到类中声明的字段（不管是public、protected、private），不包括父类。")]),e._v(" "),t("li",[e._v("field.setAccessible(true);// 将私有属性或final属性可以被访问")])]),e._v(" "),t("p",[e._v("考虑到数据实体类可能会使用继承的方式来拓展父类，即会用到父类的属性值，所以使用getFields()方法，但代价就是实体类中的属性必须是public的。")]),e._v(" "),t("h4",{attrs:{id:"_2-创建表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-创建表"}},[e._v("#")]),e._v(" 2）创建表")]),e._v(" "),t("p",[e._v("Dao类的初始化工作也包括了表的创建。一方面，因为不能在每次创建并初始化Dao类时都去重新创建一次表，所以这里就用到了sql语句中的 if not exists 关键字来避免重复创建表的问题。另一方面，其实创建表的sql语句是一种模板，两个不同的表在使用sql创建时，无非就是表名、字段名、字段类型和字段长度不同，而恰好，这些不同的元素可以使用反射+TbField注解来获取，从而实现sql语句的动态拼接，结合上一步得到的表字段与类字段的映射关系（mFieldMap），代码可以这么写：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('/**\n * 创建表（可以被子类重写，方便灵活扩展）\n */\nprotected boolean createTable(SQLiteDatabase database) {\n    StringBuilder sb = new StringBuilder();\n    for (Map.Entry<String, Field> entry : mFieldMap.entrySet()) {\n        String columnName = entry.getKey();\n        Field field = entry.getValue();\n        TbField tbField = field.getAnnotation(TbField.class);\n        int length = tbField == null ? 255 : tbField.length();\n        String type = "";\n        Class<?> fieldType = field.getType();\n        if (fieldType == String.class) {\n            type = "varchar";\n        } else if (fieldType == int.class || fieldType == Integer.class) {\n            type = "int";\n        } else if (fieldType == double.class || fieldType == Double.class) {\n            type = "double";\n        } else if (fieldType == float.class || fieldType == Float.class) {\n            type = "float";\n        }\n        if (TextUtils.isEmpty(type)) {\n            Log.e(TAG, type.getClass().getName() + "是不支持的字段");\n        } else {\n            sb.append(columnName + " " + type + "(" + length + "),");\n        }\n    }\n    sb.deleteCharAt(sb.lastIndexOf(","));\n    String s = sb.toString();\n    if (TextUtils.isEmpty(s)) {\n        Log.e(TAG, "获取不到表字段信息");\n        return false;\n    }\n    String sql = "create table if not exists " + mTbName + " (" + s + ") ";\n    Log.e(TAG, sql);\n    database.execSQL(sql);\n    return true;\n}\n')])])]),t("p",[e._v("到这里，Dao类的初始化工作就完了，下面进行CRUD的封装。")]),e._v(" "),t("h3",{attrs:{id:"_3、增"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、增"}},[e._v("#")]),e._v(" 3、增")]),e._v(" "),t("p",[e._v("我们知道，若使用原生的SQLiteDatabase将数据插入到表中，需要将数据先封装成ContentValues对象，再调用其insert()方法来执行数据插入操作。那么，现在我们拥有了一个数据实体，要做的，就是将这个数据实体转成ContentValues对象，再使用SQLiteDatabase的insert()方法来执行插入，可以说我们就是对SQLiteDatabase进行封装，总结上面的理论，代码分如下三步：")]),e._v(" "),t("ol",[t("li",[e._v("将对象中的属性转成键值对values。")]),e._v(" "),t("li",[e._v("将键值对values转成ContentValues对象。")]),e._v(" "),t("li",[e._v("使用SQLiteDatabase的insert()方法进行数据插入。")])]),e._v(" "),t("p",[e._v("结合mFieldMap，实现表数据插入的代码可以这么写：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('@Override\npublic Long insert(M entity) {\n    try {\n        Map<String, String> values = getValues(entity);\n        ContentValues cv = getContentValues(values);\n        return mDatabase.insert(mTbName, null, cv);\n    } catch (IllegalAccessException e) {\n        e.printStackTrace();\n    }\n    return 0L;\n}\n\n/**\n * 将对象中的属性转成键值对（列名--值）\n */\nprivate Map<String, String> getValues(M entity) throws IllegalAccessException {\n    Map<String, String> result = new HashMap<>();\n    for (Map.Entry<String, Field> entry : mFieldMap.entrySet()) {\n        Object value = entry.getValue().get(entity);\n        result.put(entry.getKey(), value == null ? "" : value.toString());\n    }\n    return result;\n}\n\n/**\n * 将键值对转成ContentValues\n */\nprivate ContentValues getContentValues(Map<String, String> values) {\n    ContentValues cv = new ContentValues();\n    for (Map.Entry<String, String> val : values.entrySet()) {\n        cv.put(val.getKey(), val.getValue());\n    }\n    return cv;\n}\n')])])]),t("h3",{attrs:{id:"_4、删"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、删"}},[e._v("#")]),e._v(" 4、删")]),e._v(" "),t("p",[e._v("要实现删除表数据功能，需要使用到SQLiteDatabase的delete()方法，其中whereClause和whereArgs是关键。又因为该框架是一个ORM框架，在表现层需要将删除条件使用数据实体进行封装，而框架内部则是对传入的数据实体进行解析，将对象中属性值不为null的属性拿出来作为删除的条件（这也意味着常见的数据类型不能用了，如int，但可以使用Integer来替换），可分为两步：")]),e._v(" "),t("ol",[t("li",[e._v("将对象中的属性转成键值对whereMap。")]),e._v(" "),t("li",[e._v("使用Condition类的构造函数对whereMap中value不为null的键值对取出来拼接。")])]),e._v(" "),t("p",[e._v("综上所述，BaseDao的表数据删除实现代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('@Override\npublic Integer delete(M where) {\n    try {\n        Map<String, String> whereMap = getValues(where);\n        Condition condition = new Condition(whereMap);\n        return mDatabase.delete(mTbName, condition.whereClause, condition.whereArgs);\n    } catch (IllegalAccessException e) {\n        e.printStackTrace();\n    }\n    return 0;\n}\n\nclass Condition {\n    public Condition(Map<String, String> whereMap) {\n\n        StringBuilder sb = new StringBuilder();\n        List<String> list = new ArrayList<>();\n\n        for (Map.Entry<String, String> entry : whereMap.entrySet()) {\n            if (!TextUtils.isEmpty(entry.getValue())) {\n                sb.append("and " + entry.getKey() + "=? ");\n                list.add(entry.getValue());\n            }\n        }\n        this.whereClause = sb.delete(0, 4).toString();\n        this.whereArgs = list.toArray(new String[list.size()]);\n    }\n\n    String whereClause;\n    String[] whereArgs;\n}\n')])])]),t("blockquote",[t("p",[e._v("whereClause是删除条件，是个字符串，需要使用?来作为占位符，多个条件需要使用and关键字连接，如："),t("strong",[e._v("name=? and password=?")]),e._v("。"),t("br"),e._v("\nwhereArgs则是对whereClause中占位符进行数值替换的字体串数组，如："),t("strong",[e._v('new String[]{"LQR","123456"}')]),e._v("。")])]),e._v(" "),t("h3",{attrs:{id:"_5、改"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、改"}},[e._v("#")]),e._v(" 5、改")]),e._v(" "),t("p",[e._v("通过前面对表数据增和删的代码实现，更新数据部分就比较好理解了，因为SQLiteDatabase的update()方法需要用到的参数有ContentValues对象，whereClause和whereArgs，其实就是将增和删的代码实现相加起来而已，这就不多废话，实现的代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("@Override\npublic Integer update(M entitiy, M where) {\n    try {\n        Map<String, String> values = getValues(entitiy);\n        ContentValues cv = getContentValues(values);\n\n        Map<String, String> whereMap = getValues(where);\n        Condition condition = new Condition(whereMap);\n\n        return mDatabase.update(mTbName, cv, condition.whereClause, condition.whereArgs);\n    } catch (IllegalAccessException e) {\n        e.printStackTrace();\n    }\n    return 0;\n}\n")])])]),t("h3",{attrs:{id:"_6、查"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6、查"}},[e._v("#")]),e._v(" 6、查")]),e._v(" "),t("p",[e._v("终于到了CRUD的最后一步：数据查询(Retrieve)。可以说这是数据库操作中最重要且使用频率最高的一部分了，同样的，表数据查询还是用到了SQLiteDatabase，使用其query()方法来进行表数据查询，它的参数也比较多，这里就只封装三种查询：")]),e._v(" "),t("ol",[t("li",[e._v("将符合条件的表数据全部查询出来。")]),e._v(" "),t("li",[e._v("将符合条件的表数据查询出来，并可以排序。")]),e._v(" "),t("li",[e._v("将符合条件的表数据查询出来，除了可以排序，还可以分页查询。")])]),e._v(" "),t("p",[e._v("需要注意的就是分页查询，因为SQLiteDatabase的第一页是从0开始的，而我希望的是表现层从1开始，所以框架代码中会对其进行自减处理。这三个方法的代码具体实现如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('@Override\npublic List<M> query(M where) {\n    return query(where, null);\n}\n\n@Override\npublic List<M> query(M where, String orderBy) {\n    return query(where, orderBy, null, null);\n}\n\n@Override\npublic List<M> query(M where, String orderBy, Integer page, Integer pageCount) {\n    List<M> list = null;\n    Cursor cursor = null;\n    try {\n        String limit = null;\n        if (page != null && pageCount != null) {\n            int startIndex = --page;\n            limit = (startIndex < 0 ? 0 : startIndex) + "," + pageCount;\n        }\n\n        if (where != null) {\n            Map<String, String> whereMap = getValues(where);\n            Condition condition = new Condition(whereMap);\n            cursor = mDatabase.query(mTbName, null, condition.whereClause, condition.whereArgs, null, null, orderBy, limit);\n        } else {\n            cursor = mDatabase.query(mTbName, null, null, null, null, null, orderBy, limit);\n        }\n\n\t\t// 将查询出来的表数据转成对象集合\n        list = getDataList(cursor);\n    } catch (IllegalAccessException e) {\n        e.printStackTrace();\n    } catch (InstantiationException e) {\n        e.printStackTrace();\n    } finally {\n        if (cursor != null) {\n            cursor.close();\n            cursor = null;\n        }\n    }\n    return list;\n}\n\n/**\n * 通过游标，将表中数据转成对象集合\n */\nprivate List<M> getDataList(Cursor cursor) throws IllegalAccessException, InstantiationException {\n    if (cursor != null) {\n        List<M> result = new ArrayList<>();\n        // 遍历游标，获取表中一行行的数据\n        while (cursor.moveToNext()) {\n\n            // 创建对象\n            ParameterizedType pt = (ParameterizedType) this.getClass().getGenericSuperclass();// 获取当前new的对象的 泛型的父类 类型\n            Class<M> clazz = (Class<M>) pt.getActualTypeArguments()[0];// 获取第一个类型参数的真实类型\n            M item = clazz.newInstance();\n\n            // 遍历表字段，使用游标一个个取值，赋值给新创建的对象。\n            Iterator<String> iterator = mFieldMap.keySet().iterator();\n            while (iterator.hasNext()) {\n                // 找到表字段\n                String columnName = iterator.next();\n                // 找到表字段对应的类属性\n                Field field = mFieldMap.get(columnName);\n\n                // 根据类属性类型，使用游标获取表中的值\n                Object val = null;\n                Class<?> fieldType = field.getType();\n                if (fieldType == String.class) {\n                    val = cursor.getString(cursor.getColumnIndex(columnName));\n                } else if (fieldType == int.class || fieldType == Integer.class) {\n                    val = cursor.getInt(cursor.getColumnIndex(columnName));\n                } else if (fieldType == double.class || fieldType == Double.class) {\n                    val = cursor.getDouble(cursor.getColumnIndex(columnName));\n                } else if (fieldType == float.class || fieldType == Float.class) {\n                    val = cursor.getFloat(cursor.getColumnIndex(columnName));\n                }\n\n                // 反射给对象属性赋值\n                field.set(item, val);\n            }\n            // 将对象添加到集合中\n            result.add(item);\n        }\n        return result;\n    }\n    return null;\n}\n')])])]),t("p",[e._v("至此，这个简易的数据库框架就写好了，下面来测试一下。")]),e._v(" "),t("h2",{attrs:{id:"五、测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、测试"}},[e._v("#")]),e._v(" 五、测试")]),e._v(" "),t("p",[e._v("Activity的布局很简单，我就不贴了，就是几个简单的按钮而已。")]),e._v(" "),t("h3",{attrs:{id:"_1、测试前准备"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、测试前准备"}},[e._v("#")]),e._v(" 1、测试前准备")]),e._v(" "),t("h4",{attrs:{id:"_1-user"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-user"}},[e._v("#")]),e._v(" 1）User")]),e._v(" "),t("p",[e._v("一个简单的数据实体类，没什么好说的，看代码。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('@TbName("tb_user")\npublic class User {\n\n    @TbField(value = "tb_name", length = 30)\n    public String username;\n\n    @TbField(value = "tb_password", length = 20)\n    public String password;\n\n    @TbField(value = "tb_age", length = 11)\n    public Integer age;\n\n    public User() {\n    }\n\n    public User(String username, String password) {\n        this.username = username;\n        this.password = password;\n    }\n\n    public User(String username, String password, int age) {\n        this.username = username;\n        this.password = password;\n        this.age = age;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    public Integer getAge() {\n        return age;\n    }\n\n    public void setAge(Integer age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return "[username:" + this.username + ", password:" + this.getPassword() + ", age:" + this.getAge() + "]";\n    }\n}\n')])])]),t("h4",{attrs:{id:"_2-userdao"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-userdao"}},[e._v("#")]),e._v(" 2）UserDao")]),e._v(" "),t("p",[e._v("可以看到这个UserDao中其实没什么代码，但它可以通过重写父类createTable()方法来更灵活的创建表，或自定义一些其它的方法来扩展其父类的功能。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public class UserDao extends BaseDao<User> {\n    // @Override\n    // protected boolean createTable(SQLiteDatabase database) {\n    // database.execSQL("create table if not exists t_user(tb_name varchar(30),tb_password varchar(10))");\n    // return super.createTable(database);\n    // }\n}\n')])])]),t("h3",{attrs:{id:"_2、功能测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、功能测试"}},[e._v("#")]),e._v(" 2、功能测试")]),e._v(" "),t("h4",{attrs:{id:"_1-初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-初始化"}},[e._v("#")]),e._v(" 1）初始化")]),e._v(" "),t("p",[e._v("这个框架需要指定一个数据库位置，我们在Activity的onCreate()方法中调用框架的init()方法来指定，建议最好放到自定义的Application中。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_customer_db_frame);\n    BaseDaoFactory.init(new File(getFilesDir(), "csdn_lqr.db").getAbsolutePath());\n    mUserDao = BaseDaoFactory.getInstance().getDataHelper(UserDao.class, User.class);\n    mUser = new User("CSDN_LQR", "123456", 10);\n}\n')])])]),t("h4",{attrs:{id:"_2-增"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-增"}},[e._v("#")]),e._v(" 2）增")]),e._v(" "),t("p",[e._v('往user表中插入一条username为"CSDN_LQR"，password为"123456"的数据：')]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public void insert(View view) {\n    Long insert = mUserDao.insert(mUser);\n    Toast.makeText(getApplicationContext(), "添加了" + (insert != -1 ? 1 : 0) + "条数据", Toast.LENGTH_SHORT).show();\n}\n')])])]),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210106001554.gif",alt:""}})]),e._v(" "),t("h4",{attrs:{id:"_3-删"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-删"}},[e._v("#")]),e._v(" 3）删")]),e._v(" "),t("p",[e._v('从user表中删除一条username为"CSDN_LQR"的数据：')]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public void delete(View view) {\n    User where = new User();\n    where.setUsername("CSDN_LQR");\n    Integer delete = mUserDao.delete(where);\n    Toast.makeText(getApplicationContext(), "删除了" + delete + "条数据", Toast.LENGTH_SHORT).show();\n}\n')])])]),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210106001610.gif",alt:""}})]),e._v(" "),t("h4",{attrs:{id:"_4-改"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-改"}},[e._v("#")]),e._v(" 4）改")]),e._v(" "),t("p",[e._v('将user表中username为"CSDN_LQR"的数据进行修改：')]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public void update(View view) {\n    User user = new User("LQR_CSDN", "654321", 9);\n\n    User where = new User();\n    where.setUsername("CSDN_LQR");\n\n    Integer update = mUserDao.update(user, where);\n    Toast.makeText(getApplicationContext(), "修改了" + update + "条数据", Toast.LENGTH_SHORT).show();\n}\n')])])]),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210106001633.gif",alt:""}})]),e._v(" "),t("h4",{attrs:{id:"_5-查"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-查"}},[e._v("#")]),e._v(" 5）查")]),e._v(" "),t("h5",{attrs:{id:"a-将符合条件的表数据全部查询出来"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#a-将符合条件的表数据全部查询出来"}},[e._v("#")]),e._v(" a. 将符合条件的表数据全部查询出来")]),e._v(" "),t("p",[e._v('将user表中所有username为"CSDN_LQR"的数据全部查询出来：')]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public void query1(View view) {\n    User where = new User();\n    where.setUsername("CSDN_LQR");\n\n    List<User> list = mUserDao.query(where);\n    int query = list == null ? 0 : list.size();\n    Toast.makeText(getApplicationContext(), "查出了" + query + "条数据", Toast.LENGTH_SHORT).show();\n    for (User user : list) {\n        System.out.println(user);\n    }\n}\n')])])]),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210106001653.gif",alt:""}})]),e._v(" "),t("h5",{attrs:{id:"b-将符合条件的表数据查询出来-并排序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#b-将符合条件的表数据查询出来-并排序"}},[e._v("#")]),e._v(" b. 将符合条件的表数据查询出来，并排序")]),e._v(" "),t("p",[e._v("将user表中的数据按age的正反序分别查询出来：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public void query2(View view) {\n    List<User> list = mUserDao.query(null, "tb_age asc");\n    int query = list == null ? 0 : list.size();\n    Toast.makeText(getApplicationContext(), "查出了" + query + "条数据", Toast.LENGTH_SHORT).show();\n    for (User user : list) {\n        System.out.println(user);\n    }\n}\n\npublic void query3(View view) {\n    List<User> list = mUserDao.query(null, "tb_age desc");\n    int query = list == null ? 0 : list.size();\n    Toast.makeText(getApplicationContext(), "查出了" + query + "条数据", Toast.LENGTH_SHORT).show();\n    for (User user : list) {\n        System.out.println(user);\n    }\n}\n')])])]),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210106001710.gif",alt:""}})]),e._v(" "),t("h5",{attrs:{id:"c-将符合条件的表数据查询出来-并分页。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#c-将符合条件的表数据查询出来-并分页。"}},[e._v("#")]),e._v(" c. 将符合条件的表数据查询出来，并分页。")]),e._v(" "),t("p",[e._v("只查询user表中的前2条数据：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public void query4(View view) {\n    User where = new User();\n\n    List<User> list = mUserDao.query(where, null, 1, 2);\n    int query = list == null ? 0 : list.size();\n    Toast.makeText(getApplicationContext(), "查出了" + query + "条数据", Toast.LENGTH_SHORT).show();\n    for (User user : list) {\n        System.out.println(user);\n    }\n}\n')])])]),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210106001730.gif",alt:""}})]),e._v(" "),t("p",[e._v("大成功，撒花。")]),e._v(" "),t("h3",{attrs:{id:"最后贴下demo地址"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最后贴下demo地址"}},[e._v("#")]),e._v(" 最后贴下Demo地址：")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/GitLqr/SimpleDbFrame",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/GitLqr/SimpleDbFrame"),t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=s.exports}}]);
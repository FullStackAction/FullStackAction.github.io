(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{472:function(t,e,a){"use strict";a.r(e);var n=a(21),r=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"一、简述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、简述"}},[t._v("#")]),t._v(" 一、简述")]),t._v(" "),e("p",[t._v("在上一篇"),e("a",{attrs:{href:"https://juejin.im/post/6844903485830348813",target:"_blank",rel:"noopener noreferrer"}},[t._v("《性能优化——内存泄漏（2）工具分析篇》"),e("OutboundLink")],1),t._v("中，介绍了如何使用工具帮助我们检查APP中是否存在内存泄漏、及如何定位到内存泄漏，但项目并不能完全依赖工具来检查，毕竟定位内存泄漏比较麻烦，还不如在开发时就考虑到内存泄漏问题，尽可能减少内存泄漏，后续优化才不会那么痛苦。下面就来看看开发中，哪些代码可能造成内存泄漏，及避免内存泄漏的对应解决方案。")]),t._v(" "),e("h2",{attrs:{id:"二、代码分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、代码分析"}},[t._v("#")]),t._v(" 二、代码分析")]),t._v(" "),e("h3",{attrs:{id:"_1、静态变量引起的内存泄露"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、静态变量引起的内存泄露"}},[t._v("#")]),t._v(" 1、静态变量引起的内存泄露")]),t._v(" "),e("h4",{attrs:{id:"_1-错误示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-错误示例"}},[t._v("#")]),t._v(" 1）错误示例")]),t._v(" "),e("p",[t._v("这个可以拿之前的Demo来说明，Demo代码如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("// 单例工具类\npublic class CommonUtil {\n    private static CommonUtil mInstance;\n    private Context mContext;\n    public CommonUtil(Context context) {\n        mContext = context;\n    }\n    public static CommonUtil getInstance(Context context) {\n        if (mInstance == null) {\n            synchronized (CommonUtil.class) {\n                if (mInstance == null) {\n                    mInstance = new CommonUtil(context);\n                }\n            }\n        }\n        return mInstance;\n    }\n\t...\n}\n\n// Activity中使用单例工具\npublic class MemoryLeakActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_memory_leak);\n        CommonUtil.getInstance(this);\n    }\n｝\n")])])]),e("p",[t._v("当调用getInstance()时，如果传入的context是Activity，那么只要这个单例没有被释放，则这个Activity也不会被释放，直到进程退出后才会释放。")]),t._v(" "),e("h4",{attrs:{id:"_2-解决方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-解决方案"}},[t._v("#")]),t._v(" 2）解决方案")]),t._v(" "),e("p",[t._v("不要传入Activity，可以使用getApplicationContext()来代替。")]),t._v(" "),e("h3",{attrs:{id:"_2、非静态内部类引起内存泄露-包括匿名内部类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、非静态内部类引起内存泄露-包括匿名内部类"}},[t._v("#")]),t._v(" 2、非静态内部类引起内存泄露（包括匿名内部类）")]),t._v(" "),e("blockquote",[e("p",[t._v("在Java中，非静态的内部类和匿名内部类都会隐式地持有其外部类的引用。")])]),t._v(" "),e("h4",{attrs:{id:"_1-错误示例-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-错误示例-2"}},[t._v("#")]),t._v(" 1）错误示例")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('public class MemoryLeakActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_memory_leak);\n        loadData();\n    }\n\n    public void loadData() {\n        new Thread() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(10000);\n                    System.out.println("模拟同步网络数据完毕");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }.start();\n    }\n}\n')])])]),e("p",[t._v("上面的代码中，使用Thread匿名内部类开辟线程同步网络数据，而这个内部类会隐式持有外部类的引用，当退出界面后，该内部类任务还在进行，导致该界面无法被GC回收，于是就会产生内存泄漏。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210106085640.png",alt:""}})]),t._v(" "),e("p",[t._v("APP退出后，执行GC，获取内存快照。可以看到MemoryLeakActivity的Total Count为1，说明存在内存泄漏。")]),t._v(" "),e("h4",{attrs:{id:"_2-解决方案-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-解决方案-2"}},[t._v("#")]),t._v(" 2）解决方案")]),t._v(" "),e("blockquote",[e("p",[t._v("静态的内部类不会持有外部类的引用。")])]),t._v(" "),e("h5",{attrs:{id:"_1-使用静态方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-使用静态方法"}},[t._v("#")]),t._v(" (1) 使用静态方法")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('public static void loadData() {\n    new Thread() {\n        @Override\n        public void run() {\n            try {\n                Thread.sleep(10000);\n                System.out.println("模拟同步网络数据完毕");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }.start();\n}\n')])])]),e("h5",{attrs:{id:"_2-使用静态内部类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-使用静态内部类"}},[t._v("#")]),t._v(" (2) 使用静态内部类")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('public void loadData() {\n    new MyThread().start();\n}\n\nstatic class MyThread extends Thread {\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(10000);\n            System.out.println("模拟同步网络数据完毕");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n')])])]),e("h4",{attrs:{id:"_3-拓展"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-拓展"}},[t._v("#")]),t._v(" 3）拓展")]),t._v(" "),e("p",[t._v("但项目开发中，可能会存在一定要使用内部类去持有外部类的情况，比如数据同步完成后，需要修改界面上的文本信息，而静态内部类无法直接持有外部类的引用，这又该怎么解决呢？其实可以通过内部类的构造函数将外部类传入，并使用弱引用保存（GC执行后释放），并在内部类中做好判空即可。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('static class MyThread extends Thread {\n    Reference<Context> mReference;\n\n    public MyThread(Context context) {\n        mReference = new WeakReference<>(context);\n    }\n\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(10000);\n            MemoryLeakActivity context = (MemoryLeakActivity) mReference.get();\n            if (context != null) {\n                context.mTv.setText("模拟同步网络数据完毕");\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n')])])]),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210106085706.png",alt:""}})]),t._v(" "),e("p",[t._v("APP退出后，执行GC，获取内存快照。可以看到MemoryLeakActivity的Total Count为0，说明没有内存泄漏。")]),t._v(" "),e("h3",{attrs:{id:"_3、不需要用的监听未移除会发生内存泄露"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、不需要用的监听未移除会发生内存泄露"}},[t._v("#")]),t._v(" 3、不需要用的监听未移除会发生内存泄露")]),t._v(" "),e("h4",{attrs:{id:"_1-错误示例-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-错误示例-3"}},[t._v("#")]),t._v(" 1）错误示例")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("public class MemoryLeakActivity extends AppCompatActivity implements SensorEventListener {\n\n    private SensorManager mSm;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_memory_leak);\n\n        mSm = (SensorManager) getSystemService(SENSOR_SERVICE);\n        Sensor sensor = mSm.getDefaultSensor(Sensor.TYPE_ALL);\n        mSm.registerListener(this, sensor, SensorManager.SENSOR_DELAY_NORMAL);\n    }\n}\n")])])]),e("p",[t._v("本例中使用getSystemService()获取传感器服务，并设置了监听，但没有在onDestroy()方法中将监听移除，此类监听没有及时清除的话，必定造成内存泄漏。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210106085718.png",alt:""}})]),t._v(" "),e("h4",{attrs:{id:"_2-解决方案-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-解决方案-3"}},[t._v("#")]),t._v(" 2）解决方案")]),t._v(" "),e("p",[t._v("只需在onDestroy()中移除监听即可。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("@Override\nprotected void onDestroy() {\n    super.onDestroy();\n    mSm.unregisterListener(this);\n}\n")])])]),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210106085730.png",alt:""}})]),t._v(" "),e("h3",{attrs:{id:"_4、资源未关闭引起的内存泄露情况"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、资源未关闭引起的内存泄露情况"}},[t._v("#")]),t._v(" 4、资源未关闭引起的内存泄露情况")]),t._v(" "),e("h4",{attrs:{id:"_1-错误示例-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-错误示例-4"}},[t._v("#")]),t._v(" 1）错误示例")]),t._v(" "),e("p",[t._v("比如：BroadCastReceiver、Cursor、Bitmap、IO流、自定义属性。\n当不需要使用的时候，要记得及时释放资源。否则就会内存泄露。")]),t._v(" "),e("h4",{attrs:{id:"_2-解决方案-4"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-解决方案-4"}},[t._v("#")]),t._v(" 2）解决方案")]),t._v(" "),e("p",[t._v("这里以Cursor、IO流和自定义属性为例。")]),t._v(" "),e("h5",{attrs:{id:"_1-cursor或io流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-cursor或io流"}},[t._v("#")]),t._v(" (1)Cursor或IO流")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("try {\n    ...\n    使用cursor/io读取数据操作\n    ...\n} catch (Exception e) {\n    e.printStackTrace();\n} finally {\n    if (cursor/io != null) {\n        cursor/io.close();\n        cursor/io = null;\n    }\n}\n")])])]),e("h5",{attrs:{id:"_2-自定义属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-自定义属性"}},[t._v("#")]),t._v(" (2)自定义属性")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("TypedArray a = theme.obtainStyledAttributes(attrs,\n                com.android.internal.R.styleable.TextViewAppearance, defStyleAttr, defStyleRes);\nTypedArray appearance = null;\nint ap = a.getResourceId(\n        com.android.internal.R.styleable.TextViewAppearance_textAppearance, -1);\na.recycle();// 不执行回收会造成内存泄漏\n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[238],{648:function(i,e,_){"use strict";_.r(e);var t=_(21),v=Object(t.a)({},(function(){var i=this,e=i._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":i.$parent.slotKey}},[e("h2",{attrs:{id:"一、设计原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、设计原则"}},[i._v("#")]),i._v(" 一、设计原则")]),i._v(" "),e("ul",[e("li",[i._v("设计模式是站在设计原则的基础之上的，所以在学习设计模式之前，有必要了解一下设计原则")]),i._v(" "),e("li",[i._v("软件设计开发原则\n"),e("ul",[e("li",[i._v("为了让代码有更好的重用性，可读性，可靠性，可维护性")]),i._v(" "),e("li",[i._v("有六大原则，英文首字母拼在一起就是 SOLID（稳定的），所以也称之为 SOLID 原则")])])])]),i._v(" "),e("h3",{attrs:{id:"_1、单一职责原则-single-responsibility-principle"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、单一职责原则-single-responsibility-principle"}},[i._v("#")]),i._v(" 1、单一职责原则(Single Responsibility Principle)")]),i._v(" "),e("ul",[e("li",[i._v("一个类只负责一个功能领域中的相应职责，就一个类而言，应该只有一个引起它变化的原因")]),i._v(" "),e("li",[i._v("是实现 "),e("strong",[i._v("高内聚、低耦合")]),i._v(" 的指导方针")])]),i._v(" "),e("p",[i._v("解释：")]),i._v(" "),e("ul",[e("li",[i._v("高内聚：\n"),e("ul",[e("li",[i._v("尽可能类中的每个成员方法只完成一件事（最大限度的聚合）")]),i._v(" "),e("li",[i._v("模块内部的代码，相互之间的联系越强，内聚就越高，模块的独立性就越好")])])]),i._v(" "),e("li",[i._v("低耦合：减少类内部一个成员方法调用另一个成员方法，避免牵一发动全身")])]),i._v(" "),e("h3",{attrs:{id:"_2、开闭原则-open-closed-principle"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、开闭原则-open-closed-principle"}},[i._v("#")]),i._v(" 2、开闭原则(Open Closed Principle)")]),i._v(" "),e("ul",[e("li",[i._v("对扩展开放，对修改关闭，在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果")])]),i._v(" "),e("h3",{attrs:{id:"_3、里氏替换原则-lsp-liskov-substitution-principle"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、里氏替换原则-lsp-liskov-substitution-principle"}},[i._v("#")]),i._v(" 3、里氏替换原则 LSP (Liskov Substitution Principle)")]),i._v(" "),e("ul",[e("li",[i._v("任何基类可以出现的地方，子类一定可以出现")]),i._v(" "),e("li",[i._v("在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象")])]),i._v(" "),e("blockquote",[e("p",[i._v("例如：javaEE 开发中，controller->service->dao，这三层之间的引用都是使用的接口或基类，实际对象类型由 spring 注入决定。")])]),i._v(" "),e("h3",{attrs:{id:"_4、迪米特法则-law-of-demeter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、迪米特法则-law-of-demeter"}},[i._v("#")]),i._v(" 4、迪米特法则(Law of Demeter)")]),i._v(" "),e("ul",[e("li",[i._v("最少知道原则，一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立")]),i._v(" "),e("li",[i._v("类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大涉及")]),i._v(" "),e("li",[i._v("通过引入一个合理的第三者来降低现有对象之间的耦合度")])]),i._v(" "),e("h3",{attrs:{id:"_5、接口隔离原则-interface-segregation-principle"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5、接口隔离原则-interface-segregation-principle"}},[i._v("#")]),i._v(" 5、接口隔离原则(Interface Segregation Principle)")]),i._v(" "),e("ul",[e("li",[i._v("客户端不应该依赖那些它不需要的接口")]),i._v(" "),e("li",[i._v("使用多个隔离的接口，比使用单个接口要好，降低类之间的耦合度")])]),i._v(" "),e("h3",{attrs:{id:"_6、依赖倒转原则-dependence-inversion-principle"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6、依赖倒转原则-dependence-inversion-principle"}},[i._v("#")]),i._v(" 6、依赖倒转原则(Dependence Inversion Principle)")]),i._v(" "),e("ul",[e("li",[i._v("是开闭原则的基础，针对接口编程，依赖于抽象而不依赖于具体")]),i._v(" "),e("li",[i._v("高层模块不应该依赖底层模块，二者都应该依赖其抽象")])]),i._v(" "),e("h2",{attrs:{id:"二、什么是设计模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、什么是设计模式"}},[i._v("#")]),i._v(" 二、什么是设计模式")]),i._v(" "),e("p",[i._v("设计模式是软件开发过程中面临的一般问题的解决方案，这些解决方案是众多软件开发人员经过相当长时间的试验和错误总结出来的，可以提高代码重用性，让代码更容易被他人理解，保证代码可靠性。")]),i._v(" "),e("h3",{attrs:{id:"_1、什么是-gof-gang-of-four"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、什么是-gof-gang-of-four"}},[i._v("#")]),i._v(" 1、什么是 GOF(Gang of Four)")]),i._v(" "),e("p",[i._v("在 1994 年，由四位作者全称 GOF（全拼 Gang of Four）四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software，他们所提出的设计模式主要是基于以下面向对象设计原则：")]),i._v(" "),e("ul",[e("li",[i._v("对接口编程而不是对实现编程")]),i._v(" "),e("li",[i._v("优先使用对象组合而不是继承")])]),i._v(" "),e("h3",{attrs:{id:"_2、常见的三大设计模式分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、常见的三大设计模式分类"}},[i._v("#")]),i._v(" 2、常见的三大设计模式分类")]),i._v(" "),e("ul",[e("li",[i._v("创建型模式：提供了一种在创建对象的同时隐藏创建逻辑的方式，使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活\n"),e("ul",[e("li",[i._v("常用：工厂模式、抽象工厂模式、单例模式、建造者模式")]),i._v(" "),e("li",[i._v("不常用：原型模式")])])]),i._v(" "),e("li",[i._v("结构型模式：关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的定义\n"),e("ul",[e("li",[i._v("常用：适配器模式、桥接模式、装饰器模式、代理模式")]),i._v(" "),e("li",[i._v("不常用：组合模式、外观模式、享元模式")])])]),i._v(" "),e("li",[i._v("行为型模式：特别关注对象之间的通信\n"),e("ul",[e("li",[i._v("常用：责任链模式、迭代器模式、观察者模式、状态模式、策略模式、模板模式")]),i._v(" "),e("li",[i._v("不常用：备忘录模式、命令模式")]),i._v(" "),e("li",[i._v("几乎不用：访问者模式、中介者模式、解释器模式")])])])])])}),[],!1,null,null,null);e.default=v.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{423:function(e,t,a){"use strict";a.r(t);var n=a(21),r=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"一、简述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、简述"}},[e._v("#")]),e._v(" 一、简述")]),e._v(" "),t("p",[e._v("不管AbsListView(ListView、GridView)或是新出的RecyclerView,在使用notifyDataSetChanged方法更新列表数据时，一定要保证数据为同个对象（即hashCode要一致）。对于这个问题的论证，可以去看官方源代码，或是看我之前写的一篇博文"),t("a",{attrs:{href:"http://blog.csdn.net/csdn_lqr/article/details/50947825",target:"_blank",rel:"noopener noreferrer"}},[e._v('"解决ListViews适配器notifyDataSetChanged()无效问题"'),t("OutboundLink")],1),e._v("，相信可以帮到你。但是，这个不是本文的重点，本文重点讲解在"),t("strong",[e._v("Fragment")]),e._v('中，RecyclerView遇到notifyDataSetChanged无效的问题。如果你赶时间，可以直接看第三部分（"总结"）。')]),e._v(" "),t("h2",{attrs:{id:"二、探索"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、探索"}},[e._v("#")]),e._v(" 二、探索")]),e._v(" "),t("h3",{attrs:{id:"_1、查看数据-mdata-是否是同个对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、查看数据-mdata-是否是同个对象"}},[e._v("#")]),e._v(" 1、查看数据（mData）是否是同个对象")]),e._v(" "),t("p",[e._v("*"),t("strong",[e._v("tip:java中可以通过打印hashCode的方式判断mData是否为同个对象。")])]),e._v(" "),t("p",[e._v("注意：initData方法在onActivityCreated()中被调用。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public void initData() {\n\tif (mData == null) {\n        mData = new ArrayList<>();\n    }\n\tmData.clear();\n    ...\n\t数据填充\n\t...\n    if (mAdapter == null) {\n        mAdapter = new LQRAdapterForRecyclerView<String>(getActivity(), mData, R.layout.item_senior) {\n            @Override\n            public void convert(LQRViewHolderForRecyclerView helper, String item, int position) {\n                ...\n\t\t\t\t视图填充\n\t\t\t\t...\n            }\n        };\n        mRvList.setAdapter(mAdapter);\n        LogUtils.sf("setAdapter时mData地址：" + mData.hashCode());\n    } else {\n        mAdapter.notifyDataSetChanged();\n        LogUtils.sf("setAdapter时mData地址：" + mData.hashCode());\n    }\n}\n')])])]),t("h3",{attrs:{id:"_2、操作与结果"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、操作与结果"}},[e._v("#")]),e._v(" 2、操作与结果")]),e._v(" "),t("p",[e._v("*"),t("strong",[e._v("tip:常规对Fragment的使用，会对其进行缓存，也可能使用单例模式，反正就是短时间内不会重新创建。")])]),e._v(" "),t("h4",{attrs:{id:"_1操作一"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1操作一"}},[e._v("#")]),e._v(" ①操作一：")]),e._v(" "),t("p",[e._v("打开Activity后，切换Fragment（第一次初始化Fragment）。显示效果如下：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210107083249.png",alt:""}})]),e._v(" "),t("h4",{attrs:{id:"_2操作二"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2操作二"}},[e._v("#")]),e._v(" ②操作二：")]),e._v(" "),t("p",[e._v("切换别的Fragment后，再切回刚才的Fragment(此前该Fragment已经在存在，所以不会再次创建)。显示效果如下：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210107083308.png",alt:""}})]),e._v(" "),t("h4",{attrs:{id:"_3看控制台"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3看控制台"}},[e._v("#")]),e._v(" ③看控制台：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210107083320.png",alt:""}})]),e._v(" "),t("p",[e._v("可以看到数据对象地址一样，即为同一个。")]),e._v(" "),t("h3",{attrs:{id:"_3、查看recyclerview是否是同个对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、查看recyclerview是否是同个对象"}},[e._v("#")]),e._v(" 3、查看RecyclerView是否是同个对象")]),e._v(" "),t("p",[e._v("说实话，这个是踩坑经验丰富的网友在群里说的，如果不是他说出来，打死我也没想到，居然还有这么一个坑。从上面的结果可以看出，adapter中是有数据的没错，而且数据地址没变，所以理应notifyDataSetChanged()方法会生效。但是为什么会这样呢，这里先卖个关子，先看下面的操作。")]),e._v(" "),t("h4",{attrs:{id:"_1改下上面的代码-打印recyclerview的地址。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1改下上面的代码-打印recyclerview的地址。"}},[e._v("#")]),e._v(" ①改下上面的代码，打印RecyclerView的地址。")]),e._v(" "),t("p",[e._v("代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('public void initData() {\n\tif (mData == null) {\n        mData = new ArrayList<>();\n    }\n\tmData.clear();\n    ...\n\t数据填充\n\t...\n    if (mAdapter == null) {\n        mAdapter = new LQRAdapterForRecyclerView<String>(getActivity(), mData, R.layout.item_senior) {\n            @Override\n            public void convert(LQRViewHolderForRecyclerView helper, String item, int position) {\n                ...\n\t\t\t\t视图填充\n\t\t\t\t...\n            }\n        };\n        mRvList.setAdapter(mAdapter);\n        LogUtils.sf("setAdapter时Rv：" + mRvList.hashCode());\n    } else {\n        mAdapter.notifyDataSetChanged();\n        LogUtils.sf("notify时Rv：" + mRvList.hashCode());\n    }\n}\n')])])]),t("h4",{attrs:{id:"_2同上述操作一致。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2同上述操作一致。"}},[e._v("#")]),e._v(" ②同上述操作一致。")]),e._v(" "),t("p",[e._v("对同一个Fragment来回切换，看控制台输出。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210107083334.png",alt:""}})]),e._v(" "),t("p",[e._v("果然不一样！！！")]),e._v(" "),t("h2",{attrs:{id:"三、总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、总结"}},[e._v("#")]),e._v(" 三、总结")]),e._v(" "),t("p",[e._v("为什么在Fragment中RecyclerView的地址会发生变化呢？我们先理清一下Fragment生命周期会陆续调用的几个方法：")]),e._v(" "),t("blockquote",[t("p",[e._v("onCreate() -> onCreateView() -> onActivityCreated() -> onDestroy()")])]),e._v(" "),t("p",[e._v("中间少了几个方法，请不用在意，下面贴下我的BaseFragment代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public abstract class BaseFragment extends Fragment {\n    @Override\n    public void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        init();\n    }\n\n    @Nullable\n    @Override\n    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n        //子类不再需要设置布局ID，也不再需要使用ButterKnife.bind()\n        View rootView = inflater.inflate(provideContentViewId(), container, false);\n        ButterKnife.bind(this, rootView);\n        initView(rootView);\n        return rootView;\n    }\n\n    @Override\n    public void onActivityCreated(@Nullable Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        initData();\n        initListener();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n    }\n}\n")])])]),t("p",[e._v("当一个Fragment在来回切换时，分别调用的方法如下：")]),e._v(" "),t("p",[e._v("第一次显示：")]),e._v(" "),t("blockquote",[t("p",[e._v("onCreate() -> onCreateView() -> onActivityCreated()")])]),e._v(" "),t("p",[e._v("第二次显示：")]),e._v(" "),t("blockquote",[t("p",[e._v("onCreateView() -> onActivityCreated()")])]),e._v(" "),t("p",[e._v("这里不难理解，因为Fragment一般使用的时候会被缓存，所以，当第二次显示的时候，不会调用onCreate()。只会调用onCreateView()和onActivityCreated()，这也就是RecyclerView地址不一样的原因所在，因为控件获取操作是在initView()中进行的，即RecyclerView的获取操作在onCreateView()中，而Fragment的每次显示都会调用onCreateView()，所以RecyclerView控件会被再次获取，即重新创建一个对象（此时hashCode就变化了）。")]),e._v(" "),t("h3",{attrs:{id:"_1、结论"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、结论"}},[e._v("#")]),e._v(" 1、结论：")]),e._v(" "),t("p",[e._v("所以，在Fragment中使用RecyclerView或AbsListView控件的notifyDataSetChanged()方法时，除了保证数据(mData对象)不能变以外，控件本身一样也不能变。")]),e._v(" "),t("h3",{attrs:{id:"_2、解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、解决方案"}},[e._v("#")]),e._v(" 2、解决方案：")]),e._v(" "),t("h4",{attrs:{id:"_1-方案一"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-方案一"}},[e._v("#")]),e._v(" 1)方案一：")]),e._v(" "),t("p",[e._v("因为Fragment的onCreateView()和onActivityCreated()方法在每次Fragment显示的时候会被调用，控件会被重新创建一次，所以，解决方法只能是在这两个方法中重新对RecyclerView设置适配器，而不要使用notifyDataSetChanged()，故代码改为如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public void initData() {\n    if (mData == null) {\n        mData = new ArrayList<>();\n    }\n    mData.clear();\n    ...\n    数据填充\n    ...\n    if (mAdapter == null) {\n        mAdapter = new LQRAdapterForRecyclerView<String>(getActivity(), mData, R.layout.item_senior) {\n            @Override\n            public void convert(LQRViewHolderForRecyclerView helper, String item, int position) {\n                ...\n                视图填充\n                ...\n            }\n        };\n    } \n     mRvList.setAdapter(mAdapter);\n}\n")])])]),t("p",[e._v("注：只是建议不要在上述两个生命周期方法中使用notifyDataSetChanged()而已，只要在保证RecyclerView等列表控件设置完适配器后，可以在任意地方继续使用notifyDataSetChanged()。")]),e._v(" "),t("h4",{attrs:{id:"_2-方案二"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-方案二"}},[e._v("#")]),e._v(" 2)方案二：")]),e._v(" "),t("p",[e._v("让rootView作为全局变量，在回调onCreateView()时不再重新创建。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public abstract class BaseFragment extends Fragment {\n\n   View rootView;\n\n  @Override\n  public void onCreate(@Nullable Bundle savedInstanceState) {\n      super.onCreate(savedInstanceState);\n      init();\n  }\n\n  @Nullable\n  @Override\n  public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle  savedInstanceState) {\n      //子类不再需要设置布局ID，也不再需要使用ButterKnife.bind()\n      if(rootView == null){\n          rootView = inflater.inflate(provideContentViewId(), container, false);\n          ButterKnife.bind(this, rootView);\n          initView(rootView);\n      }\n      return rootView;\n  }\n\n  @Override\n  public void onActivityCreated(@Nullable Bundle savedInstanceState) {\n      super.onActivityCreated(savedInstanceState);\n      initData();\n      initListener();\n  }\n\n   @Override\n  public void onDestroy() {\n      super.onDestroy();\n  }\n}\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);
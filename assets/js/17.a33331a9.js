(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{427:function(e,t,r){"use strict";r.r(t);var a=r(21),i=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"一、简述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、简述"}},[e._v("#")]),e._v(" 一、简述")]),e._v(" "),t("p",[e._v("RecyclerView默认就有item动画，例如在增加或删除item时，都会有一个条目间位移的动画，但本文要说的不是这个！！！本文的主角是v7包中的ItemTouchHelper，它跟RecyclerView结合后将会带来神奇的交互效果。示例如下：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource20210320170901/image/20210107081331.gif",alt:""}})]),e._v(" "),t("p",[e._v("效果还是比较酷炫的吧，上图中有四步操作：")]),e._v(" "),t("ol",[t("li",[e._v("长按item后拖动，与其他item交换位置")]),e._v(" "),t("li",[e._v("按住item右面的图标后拖动，与其他item交换位置")]),e._v(" "),t("li",[e._v("左滑item变透明并缩小，超出屏幕后，其他item补上")]),e._v(" "),t("li",[e._v("右滑item变透明并缩小，超出屏幕后，其他item补上")])]),e._v(" "),t("p",[e._v("下面将一一实现出这些效果")]),e._v(" "),t("h2",{attrs:{id:"二、初识itemtouchhelper"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、初识itemtouchhelper"}},[e._v("#")]),e._v(" 二、初识ItemTouchHelper")]),e._v(" "),t("h3",{attrs:{id:"_1、创建itemtouchhelper"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、创建itemtouchhelper"}},[e._v("#")]),e._v(" 1、创建ItemTouchHelper")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// 创建ItemTouchHelper，并跟RecyclerView绑定\nmItemTouchHelper = new ItemTouchHelper(mCallback);\nmItemTouchHelper.attachToRecyclerView(mRv);\n")])])]),t("p",[e._v("上面就是ItemTouchHelper在本例中出场的三行代码中的两行代码，但这并不能完成上面的效果，ItemTouchHelper只是一个中间人，它将ItemTouchHelper.Callback和RecyclerView连接起来，具体效果还需要由Callback实现。")]),e._v(" "),t("h3",{attrs:{id:"_2、自定义itemtouchhelper-callback"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、自定义itemtouchhelper-callback"}},[e._v("#")]),e._v(" 2、自定义ItemTouchHelper.Callback")]),e._v(" "),t("h4",{attrs:{id:"_1-创建一个自己的callback"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-创建一个自己的callback"}},[e._v("#")]),e._v(" 1）创建一个自己的Callback")]),e._v(" "),t("p",[e._v("继承ItemTouchHelper.Callback后必须实现如下三个方法。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public class MyItemTouchHelperCallback extends ItemTouchHelper.Callback {\n\n    @Override\n    public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {\n        return 0;\n    }\n\n    @Override\n    public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder targetViewHolder) {\n        return false;\n    }\n\n    @Override\n    public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) {\n\n    }\n}\n")])])]),t("h4",{attrs:{id:"_2-重写getmovementflags"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-重写getmovementflags"}},[e._v("#")]),e._v(" 2）重写getMovementFlags()")]),e._v(" "),t("p",[e._v("getMovementFlags()是用来判断RecyclerView上的哪些方向操作交由ItemTouchHelper.Callback控制，详细介绍如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("/**\n * 获取动作标识\n * 动作标识分：dragFlags和swipeFlags\n * dragFlags：列表滚动方向的动作标识（如竖直列表就是上和下，水平列表就是左和右）\n * wipeFlags：与列表滚动方向垂直的动作标识（如竖直列表就是左和右，水平列表就是上和下）\n */\n@Override\npublic int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {\n\t// 如果你不想上下拖动，可以将 dragFlags = 0\n    int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;\n\n\t// 如果你不想左右滑动，可以将 swipeFlags = 0\n    int swipeFlags = ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;\n\n\t//最终的动作标识（flags）必须要用makeMovementFlags()方法生成\n    int flags = makeMovementFlags(dragFlags, swipeFlags);\n    return flags;\n}\n")])])]),t("p",[e._v("上面我让item的上下左右都交由ItemTouchHelper.Callback控制，看下效果：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource20210320170901/image/20210107081351.gif",alt:""}})]),e._v(" "),t("p",[e._v("可以看到左右有效，但上下无效。仔细想想也是，本来就是竖直滚动列表，如果上下都直接交给ItemTouchHelper.Callback控制了，那RecyclerView的列表滚动功能该怎么办？所以，要触发上下拖动的交互效果，肯定有其他开启的方式。")]),e._v(" "),t("h4",{attrs:{id:"_3-开启长按item拖动效果"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-开启长按item拖动效果"}},[e._v("#")]),e._v(" 3）开启长按item拖动效果")]),e._v(" "),t("p",[e._v("直接重写ItemTouchHelper.Callback的isLongPressDragEnabled()。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("/**\n * 是否开启item长按拖拽功能\n */\n@Override\npublic boolean isLongPressDragEnabled() {\n    return true;\n}\n")])])]),t("p",[e._v("默认返回是false，重写返回true。现在看下效果如何：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210107081411.gif",alt:""}})]),e._v(" "),t("p",[e._v("长按后可以拖动了，但是这样不太方便，接下来实现按住item右图标进行拖动的效果。")]),e._v(" "),t("h4",{attrs:{id:"_4-开启按住图标拖动效果"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-开启按住图标拖动效果"}},[e._v("#")]),e._v(" 4）开启按住图标拖动效果")]),e._v(" "),t("p",[e._v("ItemTouchHelper的startDrag(viewHolder)方法可以手动开启拖动效果，上面的ItemTouchHelper实例创建在Activity中，而图标实例在Adapter中，为了降低耦合，这里先写一个接口：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public interface ItemDragListener {\n    void onStartDrags(RecyclerView.ViewHolder viewHolder);\n}\n")])])]),t("p",[e._v("接口由Activity实现，在Adapter创建时传入")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public class ItemTouchHelperActivity extends AppCompatActivity implements ItemDragListener {\n\n\tprivate ItemTouchHelper mItemTouchHelper;\n\t...\n\n\tprivate void setRecyclerView() {\n        mAdapter = new ItemTouchHelperAdapter(mData, this);\n\t\t...\n    }\n\n    @Override\n    public void onStartDrags(RecyclerView.ViewHolder viewHolder) {\n        mItemTouchHelper.startDrag(viewHolder);\n    }\n}\n")])])]),t("p",[e._v("接口由Adapter的图标触摸时调用")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public class ItemTouchHelperAdapter extends RecyclerView.Adapter<ItemTouchHelperAdapter.ItemTouchHelperViewHolder>  {\n\n    private List<String> mData;\n    private ItemDragListener mItemDragListener;\n\n    public ItemTouchHelperAdapter(List<String> data, ItemDragListener itemDragListener) {\n        mData = data;\n        mItemDragListener = itemDragListener;\n    }\n\n    ...\n\n    @Override\n    public void onBindViewHolder(final ItemTouchHelperViewHolder viewHolder, int position) {\n        ...\n        viewHolder.mIvDrag.setOnTouchListener(new View.OnTouchListener() {\n            @Override\n            public boolean onTouch(View v, MotionEvent event) {\n                mItemDragListener.onStartDrags(viewHolder);\n                return false;\n            }\n        });\n    }\n｝\n")])])]),t("p",[e._v("这样在让图标在触摸时，间接的调用了mItemTouchHelper.startDrag(viewHolder)，看下效果：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210107081426.gif",alt:""}})]),e._v(" "),t("h2",{attrs:{id:"三、深入itemtouchhelper"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、深入itemtouchhelper"}},[e._v("#")]),e._v(" 三、深入ItemTouchHelper")]),e._v(" "),t("p",[e._v("上面做到了item的上下拖动和左右滑动效果，但只是当前item的动画效果罢了，下面继续完成与其他item互动的效果吧。")]),e._v(" "),t("h3",{attrs:{id:"_1、上下拖动时与其他item进行位置交换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、上下拖动时与其他item进行位置交换"}},[e._v("#")]),e._v(" 1、上下拖动时与其他item进行位置交换")]),e._v(" "),t("h4",{attrs:{id:"_1-原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-原理"}},[e._v("#")]),e._v(" 1）原理")]),e._v(" "),t("p",[e._v("其实ItemTouchHelper.Callback本身不具备将两个item互换位置的功能，但RecyclerView可以，我们可以在item拖动的时候把当前item与另一个item的数据位置交换，再调用RecyclerView的notifyItemMoved()方法刷新布局，同时，因为RecyclerView自带item动画，就可以完成上面的交互效果了。")]),e._v(" "),t("h4",{attrs:{id:"_2-实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-实现"}},[e._v("#")]),e._v(" 2）实现")]),e._v(" "),t("p",[e._v("item拖动要在ItemTouchHelper.Callback中监听，而数据交换处理要在Adapter中进行，为了降低耦合，这里先写一个接口：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public interface ItemMoveListener {\n    boolean onItemMove(int fromPosition, int toPosition);\n}\n")])])]),t("p",[e._v("接口由Adapter实现")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public class ItemTouchHelperAdapter extends RecyclerView.Adapter<ItemTouchHelperAdapter.ItemTouchHelperViewHolder> implements ItemMoveListener{\n\n    ...\n\n\t@Override\n    public boolean onItemMove(int fromPosition, int toPosition) {\n        //1、交换数据\n        Collections.swap(mData, fromPosition, toPosition);\n        //2、刷新\n        notifyItemMoved(fromPosition, toPosition);\n        return true;\n    }\n}\n")])])]),t("p",[e._v("接口在创建ItemTouchHelper.Callback时传入，在onMove()中调用")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public class MyItemTouchHelperCallback extends ItemTouchHelper.Callback {\n\n    ItemMoveListener mItemMoveListener;\n\n    public MyItemTouchHelperCallback(ItemMoveListener itemMoveListener) {\n        mItemMoveListener = itemMoveListener;\n    }\n\n\t...\t\t\n\n    /**\n     * 当item拖拽移动时触发\n     *\n     * @param recyclerView\n     * @param viewHolder       当前被拖拽的item的viewHolder\n     * @param targetViewHolder 当前被拖拽的item下方的另一个item的viewHolder\n     * @return\n     */\n    @Override\n    public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder targetViewHolder) {\n        return mItemMoveListener.onItemMove(viewHolder.getAdapterPosition(), targetViewHolder.getAdapterPosition());\n    }\n}\n")])])]),t("h4",{attrs:{id:"_3-效果"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-效果"}},[e._v("#")]),e._v(" 3）效果：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210107081447.gif",alt:""}})]),e._v(" "),t("h3",{attrs:{id:"_2、左右滑出屏幕时其他item补上"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、左右滑出屏幕时其他item补上"}},[e._v("#")]),e._v(" 2、左右滑出屏幕时其他item补上")]),e._v(" "),t("h4",{attrs:{id:"_1-原理-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-原理-2"}},[e._v("#")]),e._v(" 1）原理")]),e._v(" "),t("p",[e._v("相同的，只要在item滑出屏幕时，将对应的数据删掉，再调用RecyclerView的notifyItemRemoved()方法刷新布局即可。")]),e._v(" "),t("h4",{attrs:{id:"_2-实现-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-实现-2"}},[e._v("#")]),e._v(" 2）实现")]),e._v(" "),t("p",[e._v("item滑动要在ItemTouchHelper.Callback中监听，而数据删除处理要在Adapter中进行，所以只需要加上面的接口中增加一个方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public interface ItemMoveListener {\n    ...\n    boolean onItemRemove(int position);\n}\n")])])]),t("p",[e._v("接口由Adapter实现")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("public class ItemTouchHelperAdapter extends RecyclerView.Adapter<ItemTouchHelperAdapter.ItemTouchHelperViewHolder> implements ItemMoveListener{\n\n    ...\n\n    @Override\n    public boolean onItemRemove(int position) {\n        //1、删除数据\n        mData.remove(position);\n        //2、刷新\n        notifyItemRemoved(position);\n        return true;\n    }\n}\n")])])]),t("p",[e._v("接口在ItemTouchHelper.Callback在onSwiped()中调用")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("/**\n * 当item侧滑出去时触发（竖直列表是侧滑，水平列表是竖滑）\n *\n * @param viewHolder\n * @param direction  滑动的方向\n */\n@Override\npublic void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) {\n    mItemMoveListener.onItemRemove(viewHolder.getAdapterPosition());\n}\n")])])]),t("h4",{attrs:{id:"_3-效果-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-效果-2"}},[e._v("#")]),e._v(" 3）效果：")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210107081507.gif",alt:""}})]),e._v(" "),t("p",[e._v("现在大部分效果已经实现，接下来是细节处理。")]),e._v(" "),t("h3",{attrs:{id:"_3、交互时背景变化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、交互时背景变化"}},[e._v("#")]),e._v(" 3、交互时背景变化")]),e._v(" "),t("h4",{attrs:{id:"_1-原理-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-原理-3"}},[e._v("#")]),e._v(" 1）原理")]),e._v(" "),t("p",[e._v("在item被拖拽或侧滑时修改背景色，当动作结束后将背景色恢复回来，而ItemTouchHelper.Callback中正好有对应这两个状态的方法，分别是：onSelectedChanged()、clearView()。")]),e._v(" "),t("h4",{attrs:{id:"_2-实现-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-实现-3"}},[e._v("#")]),e._v(" 2）实现")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("/**\n * 当item被拖拽或侧滑时触发\n *\n * @param viewHolder\n * @param actionState 当前item的状态\n */\n@Override\npublic void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState) {\n    super.onSelectedChanged(viewHolder, actionState);\n    //不管是拖拽或是侧滑，背景色都要变化\n    if (actionState != ItemTouchHelper.ACTION_STATE_IDLE)\n        viewHolder.itemView.setBackgroundColor(viewHolder.itemView.getContext().getResources().getColor(android.R.color.darker_gray));\n}\n\n/**\n * 当item的交互动画结束时触发\n *\n * @param recyclerView\n * @param viewHolder\n */\n@Override\npublic void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {\n    super.clearView(recyclerView, viewHolder);\n    viewHolder.itemView.setBackgroundColor(viewHolder.itemView.getContext().getResources().getColor(android.R.color.white));\n}\n")])])]),t("h4",{attrs:{id:"_3-效果-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-效果-3"}},[e._v("#")]),e._v(" 3）效果")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource20210320170901/image/20210107081526.gif",alt:""}})]),e._v(" "),t("h3",{attrs:{id:"_4、左右滑动时item渐变"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、左右滑动时item渐变"}},[e._v("#")]),e._v(" 4、左右滑动时item渐变")]),e._v(" "),t("h4",{attrs:{id:"_1-分析及实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-分析及实现"}},[e._v("#")]),e._v(" 1）分析及实现")]),e._v(" "),t("p",[e._v("在最开始的图中，当item被侧滑出去的过程中，可以看到item的透明度在渐渐变浅，高度在渐渐变小，其实就是让item执行了两种属性动画而已，在ItemTouchHelper.Callback中有一个方法可以拿到item被拖拽或滑动时的位移变化，那就是onChildDraw()方法，这样就很好办了，看如下代码实现：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("@Override\npublic void onChildDraw(Canvas c, RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, float dX, float dY, int actionState, boolean isCurrentlyActive) {\n\n\t//这句代码就是item拖拽和滑动效果的实现，所以这句不能省略\n    super.onChildDraw(c, recyclerView, viewHolder, dX, dY, actionState, isCurrentlyActive);\n\n\t//我们只需要在左右滑动时，将透明度和高度的值变小（1 --\x3e 0）\n    if (actionState == ItemTouchHelper.ACTION_STATE_SWIPE) {\n        float value = 1 - Math.abs(dX) / viewHolder.itemView.getWidth();\n        viewHolder.itemView.setAlpha(value);\n        viewHolder.itemView.setScaleY(value);\n    }\n}\n")])])]),t("h4",{attrs:{id:"_2-效果-有瑕疵"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-效果-有瑕疵"}},[e._v("#")]),e._v(" 2）效果（有瑕疵）")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210107081542.gif",alt:""}})]),e._v(" "),t("p",[e._v("可以看到，item在滑动过程中渐渐透明并高度缩小了，但是，我明明是删除了两条，怎么结果列表中多出来两条空白的数据！这又是为什么呢？")]),e._v(" "),t("h4",{attrs:{id:"_3-修复"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-修复"}},[e._v("#")]),e._v(" 3）修复")]),e._v(" "),t("p",[e._v("其实上图中并不是多出了两条空白数据，它们是正常的数据，只是看不到了，这是因为RecyclerView条目（itemView）覆用导致的，前面在onChildDraw()方法中对itemView设置了透明和缩小，而一个列表中固定只有几个itemView而已，当那两个透明缩小的itemView被再次使用时，之前设置的透明度和高度比例已经是0，所以就出现了这种情况，解决方法也很简单，只要在item被移除后，将itemView的透明度和高度比例设置回来即可，代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("/**\n * 当item的交互动画结束时触发\n *\n * @param recyclerView\n * @param viewHolder\n */\n@Override\npublic void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {\n    super.clearView(recyclerView, viewHolder);\n    ...\n\n    viewHolder.itemView.setAlpha(1);\n    viewHolder.itemView.setScaleY(1);\n}\n")])])]),t("h4",{attrs:{id:"_4-效果-完美"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-效果-完美"}},[e._v("#")]),e._v(" 4）效果（完美）")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210107081559.gif",alt:""}})]),e._v(" "),t("p",[e._v("到这里，最开始的所有交互效果都已经实现了。")]),e._v(" "),t("h3",{attrs:{id:"最后附上demo链接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最后附上demo链接"}},[e._v("#")]),e._v(" 最后附上Demo链接")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://github.com/GitLqr/MaterialDesignDemo",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/GitLqr/MaterialDesignDemo"),t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=i.exports}}]);
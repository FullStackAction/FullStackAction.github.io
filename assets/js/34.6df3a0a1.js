(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{444:function(e,a,t){"use strict";t.r(a);var n=t(21),i=Object(n.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"一、简述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、简述"}},[e._v("#")]),e._v(" 一、简述")]),e._v(" "),a("p",[e._v("我们知道，数据结构中有两种存储结构，分别是：顺序存储结构（线性表）、链式存储结构（链表），在java中，对这两种结构分别进行实现的类有：")]),e._v(" "),a("ul",[a("li",[e._v("顺序存储结构：ArrayList、Stack")]),e._v(" "),a("li",[e._v("链式存储结构：LinkedList、Queue")])]),e._v(" "),a("p",[e._v("本篇只对ArrayList的源码进行分析，对于其他类的源码分析可通过本人博客列表进行查看。")]),e._v(" "),a("h2",{attrs:{id:"二、分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、分析"}},[e._v("#")]),e._v(" 二、分析")]),e._v(" "),a("h3",{attrs:{id:"list"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[e._v("#")]),e._v(" List")]),e._v(" "),a("p",[e._v("在分析ArrayList之前，我们先来看看集合的接口——List。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("public interface List<E> extends Collection<E> {\n    boolean add(E e);\n    void add(int index, E element);\n    boolean remove(Object o);\n    E remove(int index);\n    E set(int index, E element);\n    E get(int index);\n\t...\n}\n")])])]),a("p",[e._v("在List这个接口中，提供了对集合进行操作的增、删、改、查方法，我们知道，ArrayList和LinkedList都实现了List接口，但它们的底层实现分别是线性表与链表，所以，对应的增、删、改、查方法肯定也不一样，下面的分析也将从这几个方法入手。")]),e._v(" "),a("h3",{attrs:{id:"arraylist"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#arraylist"}},[e._v("#")]),e._v(" ArrayList")]),e._v(" "),a("h4",{attrs:{id:"_1、成员变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、成员变量"}},[e._v("#")]),e._v(" 1、成员变量")]),e._v(" "),a("p",[e._v("在ArrayList的源码中，成员变量并不多，下面就截出其中几个重要的变量进行说明。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable{\n\t...\n    private static final int DEFAULT_CAPACITY = 10;\n    private static final Object[] EMPTY_ELEMENTDATA = {};\n\tprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n    transient Object[] elementData;\n    private int size;\n\t...\n}\n")])])]),a("ul",[a("li",[e._v("DEFAULT_CAPACITY：默认的数组长度")]),e._v(" "),a("li",[e._v("EMPTY_ELEMENTDATA：默认的空数组")]),e._v(" "),a("li",[e._v("DEFAULTCAPACITY_EMPTY_ELEMENTDATA：默认的空数组（与EMPTY_ELEMENTDATA有点区别，在不同的构造函数中用到）")]),e._v(" "),a("li",[e._v("elementData：真正用于存放数据的数组")]),e._v(" "),a("li",[e._v("size：数组元素个数")])]),e._v(" "),a("blockquote",[a("p",[e._v("ArrayList的底层实现是数组，数组必定是有限长度的，ArrayList中默认的数组大小是10。")])]),e._v(" "),a("h4",{attrs:{id:"_2、构造函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、构造函数"}},[e._v("#")]),e._v(" 2、构造函数")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("public ArrayList() {\n    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n")])])]),a("p",[e._v("这个构造函数是开发最常用的，可以看到，它仅仅只是让elementData等于一个空数组（DEFAULTCAPACITY_EMPTY_ELEMENTDATA）而已。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v('public ArrayList(int initialCapacity) {\n    if (initialCapacity > 0) {\n        this.elementData = new Object[initialCapacity];\n    } else if (initialCapacity == 0) {\n        this.elementData = EMPTY_ELEMENTDATA;\n    } else {\n        throw new IllegalArgumentException("Illegal Capacity: "+\n                                           initialCapacity);\n    }\n}\n')])])]),a("p",[e._v("这个构造函数可以指定初始化数组的长度，当initialCapacity大于0时，为elementData创建一个长度为initialCapacity的Object数组；当initialCapacity等于0时，则让elementData等于一个空数组（EMPTY_ELEMENTDATA）。")]),e._v(" "),a("h4",{attrs:{id:"_3、增"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、增"}},[e._v("#")]),e._v(" 3、增")]),e._v(" "),a("h5",{attrs:{id:"_1-add-e-e"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-add-e-e"}},[e._v("#")]),e._v(" 1）add(E e)")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("public boolean add(E e) {\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n}\n")])])]),a("p",[e._v("在前面已经提到了，size是一个成员变量，表示ArrayList中的元素个数。在这个方法中，先调用了ensureCapacityInternal()方法确保数组有足够的容量，再对将元素添加到elementData数组中。下面就来看看ensureCapacityInternal()方法是如何确保数组有足够的容量的。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("private void ensureCapacityInternal(int minCapacity) {\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n\n    ensureExplicitCapacity(minCapacity);\n}\n")])])]),a("p",[e._v("该方法结合ensureExplicitCapacity()方法，总的来说就是计算并扩大最小的容器体积。")]),e._v(" "),a("blockquote",[a("p",[e._v("这里就用到了DEFAULTCAPACITY_EMPTY_ELEMENTDATA这个空数组，如果此时elementData与DEFAULTCAPACITY_EMPTY_ELEMENTDATA相等，说明开发者使用的是无参构造函数创建了集合，而且是添加第一个元素，此时的容器大小为0。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("private void ensureExplicitCapacity(int minCapacity) {\n    modCount++;\n\n    // overflow-conscious code\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n")])])]),a("p",[e._v("当minCapacity - elementData.length > 0时，说明当前数组（容器）的空间不够了，需要扩容，所以调用grow()方法。")]),e._v(" "),a("blockquote",[a("p",[e._v("modCount只是一个计数变量而已，源码中有很多地方出现，无须理会。")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("private void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n")])])]),a("p",[e._v("grow()方法是用来给ArrayList集合进行扩容的，它计算出新的容器大小（即newCapacity），并确保了newCapacity不会比minCapacity小，最后调用Arrays.copyOf()创建一个新的数组并将数据拷贝到新数组中，最后让elementData进行引用。")]),e._v(" "),a("blockquote",[a("p",[e._v("oldCapacity >> 1 等价于 oldCapacity / 2，也就是说ArrayList默认的扩容大小是当前数组大小的一半。")])]),e._v(" "),a("h5",{attrs:{id:"_2-add-int-index-e-element"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-add-int-index-e-element"}},[e._v("#")]),e._v(" 2）add(int index, E element)")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("public void add(int index, E element) {\n    rangeCheckForAdd(index);\n\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    System.arraycopy(elementData, index, elementData, index + 1,\n                     size - index);\n    elementData[index] = element;\n    size++;\n}\n")])])]),a("p",[e._v('经过对add(E e)方法进行分析，这个增加方法就很容易理解了，它先确保容器有足够大的空间，没有就扩容，然后将elementData数组中从index位置开始的所有元素往后"移动"1位，再对数组的index位置进行元素赋值，最后将记录集合中元素个数的size变量加1。')]),e._v(" "),a("h4",{attrs:{id:"_4、删"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、删"}},[e._v("#")]),e._v(" 4、删")]),e._v(" "),a("h5",{attrs:{id:"_1-remove-int-index"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-remove-int-index"}},[e._v("#")]),e._v(" 1）remove(int index)")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("public E remove(int index) {\n    rangeCheck(index);\n\n    modCount++;\n    E oldValue = elementData(index);\n\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n\n    return oldValue;\n}\n")])])]),a("p",[e._v('numMoved表示在执行删除操作时数组需要移动的元素个数，将elementData数组中从index后一位开始的所有元素（即numMoved个元素）往前"移动"1位（这样一移动，index位置的元素会被后面的元素覆盖，间接起到了删除元素的作用），然后把最后的那个元素置空，同时将size变量减1。')]),e._v(" "),a("h5",{attrs:{id:"_2-remove-object-o"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-remove-object-o"}},[e._v("#")]),e._v(" 2）remove(Object o)")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("public boolean remove(Object o) {\n    if (o == null) {\n        for (int index = 0; index < size; index++)\n            if (elementData[index] == null) {\n                fastRemove(index);\n                return true;\n            }\n    } else {\n        for (int index = 0; index < size; index++)\n            if (o.equals(elementData[index])) {\n                fastRemove(index);\n                return true;\n            }\n    }\n    return false;\n}\nprivate void fastRemove(int index) {\n    modCount++;\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    elementData[--size] = null; // clear to let GC do its work\n}\n")])])]),a("p",[e._v("该方法的操作与remove(int index)基本一致，这里就不再说明了。（fastRemove()方法的代码不是可以复用么。。。）")]),e._v(" "),a("h4",{attrs:{id:"_5、查-改"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、查-改"}},[e._v("#")]),e._v(" 5、查 & 改")]),e._v(" "),a("p",[e._v("ArrayList的修改和获取元素的方法相当简单，就是对elementData数组进行简单操作罢了，这里就列出源码看看就好了。")]),e._v(" "),a("h5",{attrs:{id:"_1-get-int-index"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-get-int-index"}},[e._v("#")]),e._v(" 1）get(int index)")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("public E get(int index) {\n    rangeCheck(index);\n    return elementData(index);\n}\n\nE elementData(int index) {\n    return (E) elementData[index];\n}\n")])])]),a("h5",{attrs:{id:"_2-set-int-index-e-element"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-set-int-index-e-element"}},[e._v("#")]),e._v(" 2）set(int index, E element)")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("public E set(int index, E element) {\n    rangeCheck(index);\n\n    E oldValue = elementData(index);\n    elementData[index] = element;\n    return oldValue;\n}\n")])])]),a("h2",{attrs:{id:"三、总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、总结"}},[e._v("#")]),e._v(" 三、总结")]),e._v(" "),a("ol",[a("li",[e._v("ArrayList底层实现是数组。")]),e._v(" "),a("li",[e._v("当使用无参数构造函数创建ArrayList对象时，ArrayList对象中的数组初始长度为0（是一个空数组）。")]),e._v(" "),a("li",[e._v("ArrayList的扩容策略是每次都增加当前数组长度的一半（非固定分配）。")]),e._v(" "),a("li",[e._v("ArrayList的扩容方式是直接创建一个新的数组，并将数据拷贝到新数组中。")])])])}),[],!1,null,null,null);a.default=i.exports}}]);
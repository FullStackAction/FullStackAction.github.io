(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{382:function(e,n,t){"use strict";t.r(n);var i=t(15),s=Object(i.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"一、简述"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、简述"}},[e._v("#")]),e._v(" 一、简述")]),e._v(" "),n("p",[e._v("上篇已经分析了基于数组实现数据存储的ArrayList（线性表），而本篇的主角是LinkedList，这个使用了链表实现数据存储的集合，它的增、删、查、改方式又会是怎样的呢？下面就开始对LinkedList的源码进行分析吧。")]),e._v(" "),n("h2",{attrs:{id:"二、分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、分析"}},[e._v("#")]),e._v(" 二、分析")]),e._v(" "),n("h3",{attrs:{id:"list"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[e._v("#")]),e._v(" List")]),e._v(" "),n("p",[e._v("在分析LinkedList之前，还是先瞄一眼List接口，虽然前篇已经看过一遍了，但为了明确下文的分析方向，还是先把List接口中的几个增删改查方法再列一次。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public interface List<E> extends Collection<E> {\n    boolean add(E e);\n    void add(int index, E element);\n    boolean remove(Object o);\n    E remove(int index);\n    E set(int index, E element);\n    E get(int index);\n\t...\n}\n")])])]),n("h3",{attrs:{id:"linkedlist"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#linkedlist"}},[e._v("#")]),e._v(" LinkedList")]),e._v(" "),n("h4",{attrs:{id:"_1、成员变量"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1、成员变量"}},[e._v("#")]),e._v(" 1、成员变量")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable{\n    transient int size = 0;\n    transient Node<E> first;\n    transient Node<E> last;\n\t...\n}\n")])])]),n("ul",[n("li",[e._v("size：数组元素个数")]),e._v(" "),n("li",[e._v("first：头节点")]),e._v(" "),n("li",[e._v("last：尾节点")])]),e._v(" "),n("p",[e._v("LinkedList的成员变量很少，就上面那3个，其中first和last都是Node类型（即节点类型），用来表示链表的头和尾，这跟ArrayList就存在着本质的区别了。")]),e._v(" "),n("blockquote",[n("p",[e._v("要注意："),n("br"),e._v('\nfirst和last仅仅只是节点而已，跟数据元素没有关系，可以认为就是2个额外的"指针"，分别指着链表的头和尾。'),n("br")])]),e._v(" "),n("h4",{attrs:{id:"_2、构造函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2、构造函数"}},[e._v("#")]),e._v(" 2、构造函数")]),e._v(" "),n("h5",{attrs:{id:"_1-linkedlist"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-linkedlist"}},[e._v("#")]),e._v(" 1）LinkedList")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public LinkedList() {\n}\n")])])]),n("p",[e._v("LinkedList的构造函数有2个，以平时最常用的构造函数为例，发现该构造函数什么事都没做。")]),e._v(" "),n("h5",{attrs:{id:"_2-node"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-node"}},[e._v("#")]),e._v(" 2）Node")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("private static class Node<E> {\n    E item;\n    Node<E> next;\n    Node<E> prev;\n\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n")])])]),n("p",[e._v("再来看看这个节点类型的类结构，它描述了一个带有两个箭头的数据节点，也就是说LinkedList是双向链表。"),n("br")]),e._v(" "),n("blockquote",[n("p",[e._v("为什么Node这个类是静态的？答案是：这跟内存泄露有关，Node类是在LinkedList类中的，也就是一个内部类，若不使用static修饰，那么Node就是一个普通的内部类，在java中，一个普通内部类在实例化之后，默认会持有外部类的引用，这就有可能造成内存泄露。但使用static修饰过的内部类（称为静态内部类），就不会有这种问题，在Android中，有很多这样的情况，如Handler的使用。好像扯远了~")])]),e._v(" "),n("p",[e._v("好了，那下面就看看LinkedList是怎么进行增、删、改、查的。")]),e._v(" "),n("h4",{attrs:{id:"_3、增"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3、增"}},[e._v("#")]),e._v(" 3、增")]),e._v(" "),n("h5",{attrs:{id:"_1-add-e-e"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-add-e-e"}},[e._v("#")]),e._v(" 1）add(E e)")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public boolean add(E e) {\n    linkLast(e);\n    return true;\n}\nvoid linkLast(E e) {\n    final Node<E> l = last;\n    final Node<E> newNode = new Node<>(l, e, null);\n    last = newNode;\n    if (l == null)\n        first = newNode;\n    else\n        l.next = newNode;\n    size++;\n    modCount++;\n}\n")])])]),n("p",[e._v("因为LinkedList是链表结构，所以每添加一个元素就是让这个元素链接到链表的尾部。"),n("br"),e._v("\nadd(E e)的核心是linkLast()方法，它对元素进行了真正添加操作，分为以下几个步骤：")]),e._v(" "),n("ol",[n("li",[e._v('先让此时集合中的尾节点（即last"指针"指向的节点）赋给变量 l 。')]),e._v(" "),n("li",[e._v("然后，创建一个新节点，结合Node的构造函数，我们可以知道，在创建新节点（newNode）的同时，newNode的prev指向了l(即之前集合中的尾节点)，变量 l 就是newNode的前驱节点了，newNode的后继节点为null。")]),e._v(" "),n("li",[e._v("再将last指向newNode，也就是说newNode成为该链表新的末尾节点。")]),e._v(" "),n("li",[e._v("接着，判断变量 l 是否为null，若是null，说明之前集合中没有元素（此时newNode是集合中唯一一个元素），则将first指向newNode，也就是说此时的newNode既是头节点又是尾节点（要知道，这时newNode中的prev和next均是null，但被first和last同时指向）；"),n("br"),e._v("\n若变量 l 不是null，说明之前集合中已经存在了至少一个元素，则让之前集合中的尾节点（即变量 l ）的next指向newNode。（结合步骤2，此时的newNode与newNode的前驱节点 l 已经是相互指向了）")]),e._v(" "),n("li",[e._v("最后，跟ArrayList一样，让记录集合长度的size加1。")])]),e._v(" "),n("p",[e._v("通过对add(E e)方法的分析，我们也知道了，原来LinkedList中的元素就是一个个的节点（Node），而真正的数据则存放在Node之中（数据被Node的item所引用）。")]),e._v(" "),n("h5",{attrs:{id:"_2-add-int-index-e-element"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-add-int-index-e-element"}},[e._v("#")]),e._v(" 2）add(int index, E element)")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public void add(int index, E element) {\n    checkPositionIndex(index);\n\n    if (index == size)\n        linkLast(element);\n    else\n        linkBefore(element, node(index));\n}\n")])])]),n("p",[e._v("该add方法将添加集合元素分为2种情况，一种是在集合尾部添加，另一种是在集合中间或头部添加，因为第一种情况也是调用linkLast()方法，这里不再啰嗦，我们看看第二种情况，分析linkBefore(E e, Node"),n("E",[e._v(" succ)这个方法是怎么对元素进行添加操作的。")])],1),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("void linkBefore(E e, Node<E> succ) {\n    // assert succ != null;\n    final Node<E> pred = succ.prev;\n    final Node<E> newNode = new Node<>(pred, e, succ);\n    succ.prev = newNode;\n    if (pred == null)\n        first = newNode;\n    else\n        pred.next = newNode;\n    size++;\n    modCount++;\n}\n")])])]),n("p",[e._v("往LinkedList集合中间或头部添加元素分为以下几个步骤：")]),e._v(" "),n("ol",[n("li",[e._v("先调用node(int index)方法得到指定位置的元素节点，也就是linkBefore()方法中的形参 succ。")]),e._v(" "),n("li",[e._v("然后，通过succ.prevt得到succ的前一个元素pred。（此时拿到了第index个元素succ，和第index-1个元素pred）")]),e._v(" "),n("li",[e._v("再创建一个新节点newNode，newNode的prev指向了pred，newNode的next指向了succ。（即newNode往succ和pred的中间插入，并单向与它们分别建立联系，"),n("strong",[e._v("eg：pred ← newNode → succ")]),e._v("）")]),e._v(" "),n("li",[e._v("再让succ的prev指向newNode。（succ与跟newNode建立联系了，此时succ与newNode是双向关联，"),n("strong",[e._v("eg：pred ← newNode ⇋ succ")]),e._v("）。")]),e._v(" "),n("li",[e._v("接着，判断pred是否为null，若是null，说明之前succ是集合中的第一个元素（即index值为0），现在newNode跑到了succ前面，所以只需要将first指向newNode（"),n("strong",[e._v("eg：first ⇌ newNode ⇋ succ")]),e._v("）；"),n("br"),e._v("\n若pred不为null，则将pred的next指向newNode。（这时pred也主动与newNode建立联系了，此时pred与newNode也是双向关联，"),n("strong",[e._v("eg：pred ⇌ newNode ⇋ succ")]),e._v("）")]),e._v(" "),n("li",[e._v("最后，让记录集合长度的size加1。")])]),e._v(" "),n("p",[e._v("对于链表的操作还是有些复杂的，特别是这种双向链表，不过仔细理解下，也不是什么问题（看不懂的可以边看步骤边动手画一画）。到这里，对于LinkedList的第一个添加方法就分析完了。")]),e._v(" "),n("h6",{attrs:{id:"下面是对node-int-index-方法的分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#下面是对node-int-index-方法的分析"}},[e._v("#")]),e._v(" 下面是对node(int index)方法的分析：")]),e._v(" "),n("p",[e._v("这也是LinkedList获取元素的核心方法，相当重要，因为后面会出现很多次，这里就顺带先分析一下了。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("Node<E> node(int index) {\n    // assert isElementIndex(index);\n\n    if (index < (size >> 1)) {\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n")])])]),n("p",[e._v("  细看node(int index)方法中的代码逻辑，可以看到，它是通过遍历的方式，将集合中的元素一个个拿出来，再通过该元素的prev或next拿到下一个遍历的元素，经过index次循环后，最终才拿到了index对应的元素。"),n("br"),e._v("\n  跟ArrayList相比，因为ArrayList底层是数组实现，拥有下标这个特性，在获取元素时，不需要对集合进行遍历，所以查找某个元素会特别快（在数据量特别多的情况下，ArrayList和LinkedList在效率上的差别就相当明显了）。"),n("br"),e._v("\n  不过，LinkedList对元素的获取还是做了一定优化的，它对index与集合长度的一半做比较，来确定是在集合的前半段还是后半段进行查找。")]),e._v(" "),n("h4",{attrs:{id:"_4、删"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4、删"}},[e._v("#")]),e._v(" 4、删")]),e._v(" "),n("h5",{attrs:{id:"_1-remove-int-index"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-remove-int-index"}},[e._v("#")]),e._v(" 1）remove(int index)")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public E remove(int index) {\n    checkElementIndex(index);\n    return unlink(node(index));\n}\nE unlink(Node<E> x) {\n    // assert x != null;\n    final E element = x.item;\n    final Node<E> next = x.next;\n    final Node<E> prev = x.prev;\n\n    if (prev == null) {\n        first = next;\n    } else {\n        prev.next = next;\n        x.prev = null;\n    }\n\n    if (next == null) {\n        last = prev;\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n\n    x.item = null;\n    size--;\n    modCount++;\n    return element;\n}\n")])])]),n("p",[e._v("在remove(int index)这个方法中，先通过index和node(int index)拿到了要被删除的元素x，然后调用了unlink(Node"),n("E",[e._v(" x)方法将其删除，自然，LinkedList删除元素的核心方法就是unlink(Node"),n("E",[e._v(" x)，删除操作分以下几个步骤：")])],1)],1),e._v(" "),n("ol",[n("li",[e._v("通过要删除的元素x拿到它的前驱节点prev和后继节点next。"),n("br"),n("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210106002524.png",alt:""}}),n("br")]),e._v(" "),n("li",[e._v("若前驱节点prev为null，说明x是集合中的首个元素，直接将first指向后继节点next即可；"),n("br"),n("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210106002543.png",alt:""}}),n("br"),e._v("\n若不为null，则让前驱节点prev的next指向后继节点next，再将x的prev置空。（这时prev与x的关联就解除了，并与next建立了联系）。"),n("br"),n("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210106002554.png",alt:""}}),e._v(" "),n("br")]),e._v(" "),n("li",[e._v("若后继节点next为null，说明x是集合中的最后一个元素，直接将last指向前驱节点prev即可；（下图分别对应步骤2中的两种情况）"),n("br"),n("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210106002608.png",alt:""}}),n("br"),e._v("\n若不为null，则让后继节点next的prev指向前驱节点prev，再将x的next置空。（这时next与x的关联就解除了，并与prev建立了联系）。"),n("br"),n("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210106002619.png",alt:""}}),n("br")]),e._v(" "),n("li",[e._v("最后，让记录集合长度的size减1。")])]),e._v(" "),n("h5",{attrs:{id:"_2-remove-object-o"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-remove-object-o"}},[e._v("#")]),e._v(" 2）remove(Object o)")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public boolean remove(Object o) {\n    if (o == null) {\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (x.item == null) {\n                unlink(x);\n                return true;\n            }\n        }\n    } else {\n        for (Node<E> x = first; x != null; x = x.next) {\n            if (o.equals(x.item)) {\n                unlink(x);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n")])])]),n("p",[e._v("remove(Object o)这个删除元素的方法的形参o是数据本身，而不是LinkedList集合中的元素（节点），所以需要先通过节点遍历的方式，找到o数据对应的元素，然后再调用unlink(Node"),n("E",[e._v(" x)方法将其删除，关于unlink(Node"),n("E",[e._v(" x)的分析在第一个删除方法中已经提到了，可往回再看看。")])],1)],1),e._v(" "),n("h4",{attrs:{id:"_5、查-改"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5、查-改"}},[e._v("#")]),e._v(" 5、查 & 改")]),e._v(" "),n("p",[e._v("LinkedList集合对数据的获取与修改均通过node(int index)方法来执行往后的操作，关于node(int index)方法的分析也已经在第一个添加方法的时候已经提过，这里也就不再啰嗦了。")]),e._v(" "),n("h5",{attrs:{id:"_1-set-int-index-e-element"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-set-int-index-e-element"}},[e._v("#")]),e._v(" 1）set(int index, E element)")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public E set(int index, E element) {\n    checkElementIndex(index);\n    Node<E> x = node(index);\n    E oldVal = x.item;\n    x.item = element;\n    return oldVal;\n}\n")])])]),n("h5",{attrs:{id:"_2-get-int-index"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-get-int-index"}},[e._v("#")]),e._v(" 2）get(int index)")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public E get(int index) {\n    checkElementIndex(index);\n    return node(index).item;\n}\n")])])]),n("h2",{attrs:{id:"三、队列queue"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三、队列queue"}},[e._v("#")]),e._v(" 三、队列Queue")]),e._v(" "),n("p",[e._v("这里要顺带分析下java中的队列实现，why？因为java中队列的实现就是LinkedList，你可能会疑问，队列的英文是Queue，在java中也有对应的接口，怎么会跟LinkedList扯上关系呢？因为LinkedList实现了队列：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable {\n\t...\n}\n")])])]),n("p",[e._v("代码中的Deque是Queue的一个子接口，它继承了Queue：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public interface Deque<E> extends Queue<E> {...}\n")])])]),n("p",[e._v("从这两者的关系，不难得出，队列的实现方式也是链表。下面先来看看Queue的接口声明：")]),e._v(" "),n("h3",{attrs:{id:"_1、queue"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1、queue"}},[e._v("#")]),e._v(" 1、Queue")]),e._v(" "),n("p",[e._v("我们知道，队列是先进先出的，添加元素只能从队尾添加，删除元素只能从队头删除，Queue中的方法就体现了这种特性。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public interface Queue<E> extends Collection<E> {\n\tboolean offer(E e);\n\tE poll();\n\tE peek();\n\t...\n}\n")])])]),n("ul",[n("li",[e._v("offer()：添加队尾元素")]),e._v(" "),n("li",[e._v("poll()：删除队头元素")]),e._v(" "),n("li",[e._v("peek()：获取队头元素")])]),e._v(" "),n("p",[e._v("从上面这几个方法出发，来看看LinkedList是如何实现的。")]),e._v(" "),n("h3",{attrs:{id:"_2、linkedlist对queue的实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2、linkedlist对queue的实现"}},[e._v("#")]),e._v(" 2、LinkedList对Queue的实现")]),e._v(" "),n("h4",{attrs:{id:"_1-增"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-增"}},[e._v("#")]),e._v(" 1）增")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public boolean offer(E e) {\n    return add(e);\n}\n")])])]),n("p",[e._v("可以看到，在LinkedList中，队列的offer(E e)方法实际上是调用了LinkedList的add(E e)，add(E e)已经在最前面分析过了，就是在链表的尾部添加一个元素~")]),e._v(" "),n("h4",{attrs:{id:"_2-删"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-删"}},[e._v("#")]),e._v(" 2）删")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public E poll() {\n    final Node<E> f = first;\n    return (f == null) ? null : unlinkFirst(f);\n}\n\nprivate E unlinkFirst(Node<E> f) {\n    // assert f == first && f != null;\n    final E element = f.item;\n    final Node<E> next = f.next;\n    f.item = null;\n    f.next = null; // help GC\n    first = next;\n    if (next == null)\n        last = null;\n    else\n        next.prev = null;\n    size--;\n    modCount++;\n    return element;\n}\n")])])]),n("p",[e._v("poll()方法先拿到队头元素 f ，若 f 不为null，就调用unlinkFirst(Node"),n("E",[e._v(" f)其删除。unlinkFirst(Node"),n("E",[e._v(" f)在实现上跟unlink(Node"),n("E",[e._v(" x)差不多且相对简单，这里不做过多说明。")])],1)],1)],1),e._v(" "),n("h4",{attrs:{id:"_3-查"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-查"}},[e._v("#")]),e._v(" 3）查")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("public E peek() {\n    final Node<E> f = first;\n    return (f == null) ? null : f.item;\n}\n")])])]),n("p",[e._v("peek()先通过first拿到队头元素，然后取出元素中的数据实体返回而已。")]),e._v(" "),n("h2",{attrs:{id:"四、总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#四、总结"}},[e._v("#")]),e._v(" 四、总结")]),e._v(" "),n("ol",[n("li",[e._v("LinkedList是基于链表实现的，并且是双向链表。")]),e._v(" "),n("li",[e._v("LinkedList中的元素就是一个个的节点，而真正的数据则存放在Node之中。")]),e._v(" "),n("li",[e._v("LinkedList通过遍历的方式获取集合中的元素，效率比ArrayList低。")]),e._v(" "),n("li",[e._v("Queue队列的实现方式也是链表，java中，LinkedList是Queue的实现。")])])])}),[],!1,null,null,null);n.default=s.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{431:function(n,e,t){"use strict";t.r(e);var r=t(21),i=Object(r.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"一、简述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、简述"}},[n._v("#")]),n._v(" 一、简述")]),n._v(" "),e("p",[n._v("最近在做一个地产项目，其实之前做出了一版，但现在要求重做（连上架的机会都没有），很服气啊~~而现在做的项目呢，比上一版功能要求更多，其中，销控表的界面效果要求跟房产销冠APP的销控表界面差不多，先来看下房产销冠APP的销控表效果吧：")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource20210320170901/image/20210106083937.gif",alt:"房产销冠APP的销控表效果"}})]),n._v(" "),e("p",[n._v("说说我第一次看到这个界面效果时的感觉，就一个词：amazing~  是的，公司就我一个人做安卓开发，感觉有点压力山大，但是，不怂，静下心来分析一下就明朗多了。先说说本文核心技术重点：两个RecyclerView同步滚动。好，下面进入正文。")]),n._v(" "),e("h2",{attrs:{id:"二、分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、分析"}},[n._v("#")]),n._v(" 二、分析")]),n._v(" "),e("h3",{attrs:{id:"_1、布局分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、布局分析"}},[n._v("#")]),n._v(" 1、布局分析")]),n._v(" "),e("p",[n._v("我认为的布局实现：将销控表分为左右两部分：左边是楼层列表，右边是单元（房间）列表。楼层列表就是一个简单的LinearLayout+TextView+RecyclerView，单元（房间）列表则有点小复杂(HorizontalScrollView、LinearLayout)+TextView+RecyclerView。为了各位看客能直观理解，我特意做了张图，请看：")]),n._v(" "),e("blockquote",[e("p",[n._v("其中黄色区域就是销控表的部分。")])]),n._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210106083958.png",alt:"布局实现"}})]),n._v(" "),e("h3",{attrs:{id:"_2、效果分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、效果分析"}},[n._v("#")]),n._v(" 2、效果分析")]),n._v(" "),e("ol",[e("li",[n._v("当左边的楼层列表上下滑动时，右边的单元（房间）列表也跟着一起滑动，单元（房间）列表上的单元编号不动。")]),n._v(" "),e("li",[n._v("当右边的单元（房间）列表上下滑动时，左边的楼层列表也跟着一起滑动，单元（房间）列表上的单元编号不动。")]),n._v(" "),e("li",[n._v("当右边的单元（房间）列表左右滑动时，单元（房间）列表上的单元编号一起左右滑动，左边的楼层列表不动。")])]),n._v(" "),e("p",[n._v("那么，要实现1、2的效果，可以监听这两个列表的滚动，当其中一个列表滚动时，让另一个列表滚动相同的距离即可。要实现3的效果就简单了，因为HorizontalScrollView中嵌套RecyclerView并没有滚动冲突，HorizontalScrollView处理水平滑动事件，RecyclerView处理竖直滚动事件，所以暂时不用理（后面还是要做点简单处理的）。")]),n._v(" "),e("h2",{attrs:{id:"三、实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、实现"}},[n._v("#")]),n._v(" 三、实现")]),n._v(" "),e("h3",{attrs:{id:"_1、布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、布局"}},[n._v("#")]),n._v(" 1、布局")]),n._v(" "),e("p",[n._v("上面已经分析出了布局结构，下面直接贴布局代码：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('<?xml version="1.0" encoding="utf-8"?>\n<LinearLayout\n    xmlns:android="http://schemas.android.com/apk/res/android"\n    android:layout_width="match_parent"\n    android:layout_height="match_parent"\n    android:background="#f5f5f5"\n    android:orientation="vertical">\n\n    <android.support.design.widget.AppBarLayout\n        android:layout_width="match_parent"\n        android:layout_height="wrap_content">\n\n        <android.support.v7.widget.Toolbar\n            android:id="@+id/toolbar"\n            android:layout_width="match_parent"\n            android:layout_height="wrap_content">\n\n            <TextView\n                android:layout_width="wrap_content"\n                android:layout_height="wrap_content"\n                android:layout_gravity="center"\n                android:text="销控表"\n                android:textColor="#000"\n                android:textSize="16sp"/>\n\n            <TextView\n                android:layout_width="wrap_content"\n                android:layout_height="wrap_content"\n                android:layout_gravity="center_vertical|right"\n                android:layout_marginRight="10dp"\n                android:text="统计"\n                android:textColor="#000"\n                android:textSize="12sp"/>\n\n        </android.support.v7.widget.Toolbar>\n    </android.support.design.widget.AppBarLayout>\n\n\n    <TextView\n        android:layout_width="match_parent"\n        android:layout_height="wrap_content"\n        android:background="#fff"\n        android:gravity="center"\n        android:padding="10dp"\n        android:text="CSDN_LQR的私人后宫-项目1期-1栋"\n        android:textColor="#333"\n        android:textSize="10sp"/>\n\n    <LinearLayout\n        android:layout_width="match_parent"\n        android:layout_height="match_parent"\n        android:layout_marginTop="10px"\n        android:orientation="horizontal">\n\n        \x3c!--楼层--\x3e\n        <LinearLayout\n            android:layout_width="60dp"\n            android:layout_height="wrap_content"\n            android:orientation="vertical">\n\n            <TextView\n                android:layout_width="match_parent"\n                android:layout_height="50dp"\n                android:background="#fff"\n                android:gravity="center"\n                android:padding="10dp"\n                android:text="楼层&#x000A;单元"\n                android:textSize="12sp"/>\n\n            <android.support.v7.widget.RecyclerView\n                android:id="@+id/rv_layer"\n                android:layout_width="match_parent"\n                android:layout_height="match_parent"\n                android:layout_marginTop="1dp"/>\n\n        </LinearLayout>\n\n        \x3c!--单元(房间)--\x3e\n        <HorizontalScrollView\n            android:layout_width="match_parent"\n            android:layout_height="match_parent"\n            android:layout_marginLeft="4dp"\n            android:fillViewport="true"\n            android:scrollbars="none">\n\n            <LinearLayout\n                android:layout_width="match_parent"\n                android:layout_height="wrap_content"\n                android:orientation="vertical">\n\n                <TextView\n                    android:layout_width="match_parent"\n                    android:layout_height="50dp"\n                    android:background="#fff"\n                    android:gravity="center"\n                    android:padding="10dp"\n                    android:text="3"\n                    android:textSize="12sp"/>\n\n                <android.support.v7.widget.RecyclerView\n                    android:id="@+id/rv_room"\n                    android:layout_width="match_parent"\n                    android:layout_height="match_parent"\n                    android:layout_marginTop="1dp"/>\n            </LinearLayout>\n        </HorizontalScrollView>\n    </LinearLayout>\n</LinearLayout>\n')])])]),e("p",[n._v("再通过列表的数据进行填充（这部分不是重点就不贴出来了），效果就出来了：")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource20210320170901/image/20210106084018.gif",alt:"初步效果"}})]),n._v(" "),e("p",[n._v("接下来就是实现同步滚动效果了。")]),n._v(" "),e("h3",{attrs:{id:"_2、多recyclerview同步滚动实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、多recyclerview同步滚动实现"}},[n._v("#")]),n._v(" 2、多RecyclerView同步滚动实现")]),n._v(" "),e("p",[n._v("一个大体的思路就是分别对其中一个列表设置滚动监听，当这个列表滚动时，让另一个列表也一起滚动。\n但细节上要考虑到，这种监听是双向的，A列表滚动时触发其滚动回调接口，导致B列表滚动，而此时B列表也已经设置过滚动监听，它的滚动也会触发它的滚动回调接口，导致A列表滚动，这样就形成了一个死循环。所以适当添加或移除滚动监听是本功能实现的重难点，下面直接贴出代码，请自行结合代码及注释理解。")]),n._v(" "),e("h4",{attrs:{id:"_1-封装一个可以自行取消监听的滚动回调接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-封装一个可以自行取消监听的滚动回调接口"}},[n._v("#")]),n._v(" 1）封装一个可以自行取消监听的滚动回调接口")]),n._v(" "),e("blockquote",[e("p",[n._v("这样的封装使我们不用在其他地方考虑列表空闲状态时的处理，会省去很多事。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("/**\n * @创建者 CSDN_LQR\n * @描述 实现一个RecyclerView.OnScrollListener的子类，当RecyclerView空闲时取消自身的滚动监听\n */\npublic class MyOnScrollListener extends RecyclerView.OnScrollListener {\n    @Override\n    public void onScrollStateChanged(RecyclerView recyclerView, int newState) {\n        super.onScrollStateChanged(recyclerView, newState);\n        if (newState == recyclerView.SCROLL_STATE_IDLE) {\n            recyclerView.removeOnScrollListener(this);\n        }\n    }\n}\n")])])]),e("h4",{attrs:{id:"_2-为楼层列表控件设置滚动监听"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-为楼层列表控件设置滚动监听"}},[n._v("#")]),n._v(" 2）为楼层列表控件设置滚动监听")]),n._v(" "),e("blockquote",[e("p",[n._v("以下两段代码涉及两个列表滚动同步和添加或移除滚动监听的时机，具体代码及注释我已经写得很清楚了，请仔细看：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("private final RecyclerView.OnScrollListener mLayerOSL = new MyOnScrollListener() {\n    @Override\n    public void onScrolled(RecyclerView recyclerView, int dx, int dy) {\n        super.onScrolled(recyclerView, dx, dy);\n        // 当楼层列表滑动时，单元（房间）列表也滑动\n        mRvRoom.scrollBy(dx, dy);\n    }\n};\n\n/**\n * 设置两个列表的同步滚动\n */\nprivate void setSyncScrollListener() {\n\tmRvLayer.addOnItemTouchListener(new RecyclerView.OnItemTouchListener() {\n\n        private int mLastY;\n\n        @Override\n        public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) {\n            // 当列表是空闲状态时\n            if (rv.getScrollState() == RecyclerView.SCROLL_STATE_IDLE) {\n                onTouchEvent(rv, e);\n            }\n            return false;\n        }\n\n        @Override\n        public void onTouchEvent(RecyclerView rv, MotionEvent e) {\n            // 若是手指按下的动作，且另一个列表处于空闲状态\n            if (e.getAction() == MotionEvent.ACTION_DOWN && mRvRoom.getScrollState() == RecyclerView.SCROLL_STATE_IDLE) {\n                // 记录当前另一个列表的y坐标并对当前列表设置滚动监听\n                mLastY = rv.getScrollY();\n                rv.addOnScrollListener(mLayerOSL);\n            } else {\n                // 若当前列表原地抬起手指时，移除当前列表的滚动监听\n                if (e.getAction() == MotionEvent.ACTION_UP && rv.getScrollY() == mLastY) {\n                    rv.removeOnScrollListener(mLayerOSL);\n                }\n            }\n        }\n\n        @Override\n        public void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept) {\n\n        }\n    });\n\n\t...\n｝\n")])])]),e("h4",{attrs:{id:"_3-为单元-房间-列表设置滚动监听"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-为单元-房间-列表设置滚动监听"}},[n._v("#")]),n._v(" 3）为单元（房间）列表设置滚动监听")]),n._v(" "),e("blockquote",[e("p",[n._v("对于单元（房间）列表滚动监听的设置，跟前面一样，我就顺便写一下好了。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("private final RecyclerView.OnScrollListener mRoomOSL = new MyOnScrollListener() {\n    @Override\n    public void onScrolled(RecyclerView recyclerView, int dx, int dy) {\n        super.onScrolled(recyclerView, dx, dy);\n        // 当单元（房间）列表滑动时，楼层列表也滑动\n        mRvLayer.scrollBy(dx, dy);\n    }\n};\n\n/**\n * 设置两个列表的同步滚动\n */\nprivate void setSyncScrollListener() {\n\n\t...\n\n    mRvRoom.addOnItemTouchListener(new RecyclerView.OnItemTouchListener() {\n\n        private int mLastY;\n\n        @Override\n        public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) {\n            if (rv.getScrollState() == RecyclerView.SCROLL_STATE_IDLE) {\n                onTouchEvent(rv, e);\n            }\n            return false;\n        }\n\n        @Override\n        public void onTouchEvent(RecyclerView rv, MotionEvent e) {\n            if (e.getAction() == MotionEvent.ACTION_DOWN && mRvLayer.getScrollState() == RecyclerView.SCROLL_STATE_IDLE) {\n                mLastY = rv.getScrollY();\n                rv.addOnScrollListener(mRoomOSL);\n            } else {\n                if (e.getAction() == MotionEvent.ACTION_UP && rv.getScrollY() == mLastY) {\n                    rv.removeOnScrollListener(mRoomOSL);\n                }\n            }\n        }\n\n        @Override\n        public void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept) {\n\n        }\n    });\n}\n")])])]),e("p",[n._v("好了，到这里同步滚动效果就实现了，先看看效果。")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource20210320170901/image/20210106084042.gif",alt:"不完美的效果"}})]),n._v(" "),e("h3",{attrs:{id:"_3、处理水平滚动列表事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、处理水平滚动列表事件"}},[n._v("#")]),n._v(" 3、处理水平滚动列表事件")]),n._v(" "),e("p",[n._v("在上图中，我们可以看到 ，同步滚动效果确实是实现了，但有个问题，只要一水平滚动后，再来滚动左边的楼层列表时程序就会崩溃，若是滚动右边的单元（房间）列表则会滚动不同步，会造成这种情况是因为，当水平滚动是时，事件被HorizontalScrollView处理了，导致右边的单元（房间）列表的滚动监听没有被移除。")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210106084058.png",alt:"代码执行解析"}})]),n._v(" "),e("p",[n._v("当我们去滚动左边的楼层列表时，会为其设置滚动监听，这时这两个列表都存在滚动监听，所以就造成了监听的递归调用（死循环），于是内存就妥妥的溢出了。下面是错误提示：")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource/image/20210106084118.png",alt:"内存溢出"}})]),n._v(" "),e("p",[n._v("所以，解决的方法就是，当HorizontalScrollView处理水平滚动事件时，取消列表的滚动监听，而ScrollView本身不支持滚动监听，所以需要重新HorizontalScrollView，向外提供滚动监听功能。自定义HorizontalScrollView代码如下：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("/**\n * @创建者 CSDN_LQR\n * @描述 自定义HorizontalScrollView，向外提供滑动监听功能\n */\npublic class ObservableHorizontalScrollView extends HorizontalScrollView {\n\n    private ScrollViewListener scrollViewListener = null;\n\n    public ObservableHorizontalScrollView(Context context) {\n        super(context);\n    }\n\n    public ObservableHorizontalScrollView(Context context, AttributeSet attrs,\n                                          int defStyle) {\n        super(context, attrs, defStyle);\n    }\n\n    public ObservableHorizontalScrollView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n\n    public void setScrollViewListener(ScrollViewListener scrollViewListener) {\n        this.scrollViewListener = scrollViewListener;\n    }\n\n    @Override\n    protected void onScrollChanged(int x, int y, int oldx, int oldy) {\n        super.onScrollChanged(x, y, oldx, oldy);\n        if (scrollViewListener != null) {\n            scrollViewListener.onScrollChanged(this, x, y, oldx, oldy);\n        }\n    }\n\n    public interface ScrollViewListener {\n        void onScrollChanged(ObservableHorizontalScrollView scrollView, int x, int y, int oldx, int oldy);\n    }\n\n}  \n")])])]),e("p",[n._v("接着就是替换代码中的HorizontalScrollView控件")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('...\n\x3c!--单元(房间)--\x3e\n<com.lqr.topsales.ObservableHorizontalScrollView\n    android:layout_width="match_parent"\n    android:layout_height="match_parent"\n    android:layout_marginLeft="4dp"\n    android:fillViewport="true"\n    android:scrollbars="none">\n\n    <LinearLayout\n        android:layout_width="match_parent"\n        android:layout_height="wrap_content"\n        android:orientation="vertical">\n\n        <TextView\n            android:layout_width="match_parent"\n            android:layout_height="50dp"\n            android:background="#fff"\n            android:gravity="center"\n            android:padding="10dp"\n            android:text="3"\n            android:textSize="12sp"/>\n\n        <android.support.v7.widget.RecyclerView\n            android:id="@+id/rv_room"\n            android:layout_width="match_parent"\n            android:layout_height="match_parent"\n            android:layout_marginTop="1dp"/>\n    </LinearLayout>\n</com.lqr.topsales.ObservableHorizontalScrollView>\n...\n')])])]),e("p",[n._v("在代码中监听HorizontalScrollView滚动，当其滚动时，移除列表控件的移动监听事件：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("mSvRoom.setScrollViewListener(new ObservableHorizontalScrollView.ScrollViewListener() {\n    @Override\n    public void onScrollChanged(ObservableHorizontalScrollView scrollView, int x, int y, int oldx, int oldy) {\n        mRvLayer.removeOnScrollListener(mLayerOSL);\n        mRvRoom.removeOnScrollListener(mRoomOSL);\n    }\n});\n")])])]),e("p",[n._v("再来试试效果：")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/FullStackAction/PicBed@resource20210320170901/image/20210106084152.gif",alt:"最终效果"}})]),n._v(" "),e("h2",{attrs:{id:"四、最后附上demo连接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、最后附上demo连接"}},[n._v("#")]),n._v(" 四、最后附上DEMO连接")]),n._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/GitLqr/TopsalesSellControlTableDemo",target:"_blank",rel:"noopener noreferrer"}},[n._v("TopsalesSellControlTableDemo"),e("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=i.exports}}]);